{"name": "mbpp_100_next_smallest_palindrome", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Next_Smallest_Palindrome (Num : Integer) return Integer;\n   -- Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Next_Smallest_Palindrome (Num : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "verbatim", "tests": "\n   end Next_Smallest_Palindrome;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num : Integer) return Integer renames Placeholder.Next_Smallest_Palindrome;\n\nbegin\n   pragma Assert (Candidate (99) = 101);\n   pragma Assert (Candidate (1221) = 1331);\n   pragma Assert (Candidate (120) = 121);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_101_kth_element", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Kth_Element (Arr : Integer_Array; K : Integer) return Integer;\n   -- Write a function to find the kth element in the given array using 1-based indexing.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Kth_Element (Arr : Integer_Array; K : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_101_kth_element.py", "prompt_terminology": "verbatim", "tests": "\n   end Kth_Element;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; K : Integer) return Integer renames Placeholder.Kth_Element;\n\nbegin\n   pragma Assert (Candidate ((12, 3, 5, 7, 19), 2) = 3);\n   pragma Assert (Candidate ((17, 24, 8, 23), 3) = 8);\n   pragma Assert (Candidate ((16, 21, 25, 36, 4), 4) = 36);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_102_snake_to_camel", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Snake_To_Camel (Word : Unbounded_String) return Unbounded_String;\n   -- Write a function to convert a snake case string to camel case string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Snake_To_Camel (Word : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "verbatim", "tests": "\n   end Snake_To_Camel;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Word : Unbounded_String) return Unbounded_String renames Placeholder.Snake_To_Camel;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python_program\")) = To_Unbounded_String (\"PythonProgram\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"python_language\")) = To_Unbounded_String (\"PythonLanguage\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"programming_language\")) = To_Unbounded_String (\"ProgrammingLanguage\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_103_eulerian_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Eulerian_Num (N : Integer; M : Integer) return Integer;\n   -- Write a function to find the Eulerian number a(n, m).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Eulerian_Num (N : Integer; M : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Eulerian_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer; M : Integer) return Integer renames Placeholder.Eulerian_Num;\n\nbegin\n   pragma Assert (Candidate (3, 1) = 4);\n   pragma Assert (Candidate (4, 1) = 11);\n   pragma Assert (Candidate (5, 3) = 26);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_104_sort_sublists", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   type Unbounded_String_Array_Array is array (Integer range <>) of Unbounded_String_Array;\n   function Sort_Sublists (Input_List : Unbounded_String_Array_Array) return Unbounded_String_Array_Array;\n   -- Write a function to sort each sublist of strings in a given list of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sort_Sublists (Input_List : Unbounded_String_Array_Array) return Unbounded_String_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_104_sort_sublists.py", "prompt_terminology": "verbatim", "tests": "\n   end Sort_Sublists;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Input_List : Unbounded_String_Array_Array) return Unbounded_String_Array_Array renames Placeholder.Sort_Sublists;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\")), (To_Unbounded_String (\"white\"), To_Unbounded_String (\"black\"), To_Unbounded_String (\"orange\")))) = ((To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\")), (To_Unbounded_String (\"black\"), To_Unbounded_String (\"orange\"), To_Unbounded_String (\"white\"))));\n   pragma Assert (Candidate (((To_Unbounded_String (\" red \"), To_Unbounded_String (\"green\")), (To_Unbounded_String (\"blue \"), To_Unbounded_String (\" black\")), (To_Unbounded_String (\" orange\"), To_Unbounded_String (\"brown\")))) = ((To_Unbounded_String (\" red \"), To_Unbounded_String (\"green\")), (To_Unbounded_String (\" black\"), To_Unbounded_String (\"blue \")), (To_Unbounded_String (\" orange\"), To_Unbounded_String (\"brown\"))));\n   pragma Assert (Candidate (((To_Unbounded_String (\"zilver\"), To_Unbounded_String (\"gold\")), (To_Unbounded_String (\"magnesium\"), To_Unbounded_String (\"aluminium\")), (To_Unbounded_String (\"steel\"), To_Unbounded_String (\"bronze\")))) = ((To_Unbounded_String (\"gold\"), To_Unbounded_String (\"zilver\")), (To_Unbounded_String (\"aluminium\"), To_Unbounded_String (\"magnesium\")), (To_Unbounded_String (\"bronze\"), To_Unbounded_String (\"steel\"))));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_105_count", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Boolean_Array is array (Integer range <>) of Boolean;\n   function Count (Lst : Boolean_Array) return Integer;\n   -- Write a python function to count true booleans in the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count (Lst : Boolean_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "verbatim", "tests": "\n   end Count;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Lst : Boolean_Array) return Integer renames Placeholder.Count;\n\nbegin\n   pragma Assert (Candidate ((True, False, True)) = 2);\n   pragma Assert (Candidate ((False, False)) = 0);\n   pragma Assert (Candidate ((True, True, True)) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_106_add_lists", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   type Integer_Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n     Integer_5 : Integer;\n   end record;\n\n   function Add_Lists (Test_List : Integer_Array; Test_Tup : Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function to append the given list to the given tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Add_Lists (Test_List : Integer_Array; Test_Tup : Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "verbatim", "tests": "\n   end Add_Lists;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Array; Test_Tup : Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Integer_Tuple renames Placeholder.Add_Lists;\n\nbegin\n   pragma Assert (Candidate ((5, 6, 7), (9, 10)) = (9, 10, 5, 6, 7));\n   pragma Assert (Candidate ((6, 7, 8), (10, 11)) = (10, 11, 6, 7, 8));\n   pragma Assert (Candidate ((7, 8, 9), (11, 12)) = (11, 12, 7, 8, 9));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_108_merge_sorted_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Merge_Sorted_List (Num1 : Integer_Array; Num2 : Integer_Array; Num3 : Integer_Array) return Integer_Array;\n   -- Write a function to merge three lists into a single sorted list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Merge_Sorted_List (Num1 : Integer_Array; Num2 : Integer_Array; Num3 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Merge_Sorted_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num1 : Integer_Array; Num2 : Integer_Array; Num3 : Integer_Array) return Integer_Array renames Placeholder.Merge_Sorted_List;\n\nbegin\n   pragma Assert (Candidate ((25, 24, 15, 4, 5, 29, 110), (19, 20, 11, 56, 25, 233, 154), (24, 26, 54, 48)) = (4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233));\n   pragma Assert (Candidate ((1, 3, 5, 6, 8, 9), (2, 5, 7, 11), (1, 4, 7, 8, 12)) = (1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12));\n   pragma Assert (Candidate ((18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1), (25, 35, 22, 85, 14, 65, 75, 25, 58), (12, 74, 9, 50, 61, 41)) = (1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_109_odd_Equivalent", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Odd_Equivalent (S : Unbounded_String; N : Integer) return Integer;\n   -- Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Odd_Equivalent (S : Unbounded_String; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "verbatim", "tests": "\n   end Odd_Equivalent;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String; N : Integer) return Integer renames Placeholder.Odd_Equivalent;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"011001\"), 6) = 3);\n   pragma Assert (Candidate (To_Unbounded_String (\"11011\"), 5) = 4);\n   pragma Assert (Candidate (To_Unbounded_String (\"1010\"), 4) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_113_check_integer", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Check_Integer (Text : Unbounded_String) return Boolean;\n   -- Write a function to check if a string represents an integer or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Integer (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Integer;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Check_Integer;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"1\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"12345\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_116_tuple_to_int", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Tuple_To_Int (Nums : Integer_Integer_Integer_Tuple) return Integer;\n   -- Write a function to convert a given tuple of positive integers into a single integer.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Tuple_To_Int (Nums : Integer_Integer_Integer_Tuple) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "verbatim", "tests": "\n   end Tuple_To_Int;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Integer_Integer_Tuple) return Integer renames Placeholder.Tuple_To_Int;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = 123);\n   pragma Assert (Candidate ((4, 5, 6)) = 456);\n   pragma Assert (Candidate ((5, 6, 7)) = 567);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_117_list_to_float", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Unbounded_String_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Unbounded_String_2 : Unbounded_String;\n   end record;\n\n   type Float_Float_Tuple_Array is array (Integer range <>) of Float_Float_Tuple;\n   type Float_Float_Tuple is record\n     Float_1 : Float;\n     Float_2 : Float;\n   end record;\n\n   type Unbounded_String_Unbounded_String_Tuple_Array is array (Integer range <>) of Unbounded_String_Unbounded_String_Tuple;\n   function List_To_Float (Test_List : Unbounded_String_Unbounded_String_Tuple_Array) return Float_Float_Tuple_Array;\n   -- Write a function to convert all possible convertible elements in a list of lists to floats.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function List_To_Float (Test_List : Unbounded_String_Unbounded_String_Tuple_Array) return Float_Float_Tuple_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py", "prompt_terminology": "verbatim", "tests": "\n   end List_To_Float;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Unbounded_String_Unbounded_String_Tuple_Array) return Float_Float_Tuple_Array renames Placeholder.List_To_Float;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"3\"), To_Unbounded_String (\"4\")), (To_Unbounded_String (\"1\"), To_Unbounded_String (\"26.45\")), (To_Unbounded_String (\"7.32\"), To_Unbounded_String (\"8\")), (To_Unbounded_String (\"4\"), To_Unbounded_String (\"8\")))) = ((3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)));\n   pragma Assert (Candidate (((To_Unbounded_String (\"4\"), To_Unbounded_String (\"4\")), (To_Unbounded_String (\"2\"), To_Unbounded_String (\"27\")), (To_Unbounded_String (\"4.12\"), To_Unbounded_String (\"9\")), (To_Unbounded_String (\"7\"), To_Unbounded_String (\"11\")))) = ((4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)));\n   pragma Assert (Candidate (((To_Unbounded_String (\"6\"), To_Unbounded_String (\"78\")), (To_Unbounded_String (\"5\"), To_Unbounded_String (\"26.45\")), (To_Unbounded_String (\"1.33\"), To_Unbounded_String (\"4\")), (To_Unbounded_String (\"82\"), To_Unbounded_String (\"13\")))) = ((6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_118_string_to_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function String_To_List (My_String : Unbounded_String) return Unbounded_String_Array;\n   -- Write a function to convert a string to a list of strings split on the space character.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function String_To_List (My_String : Unbounded_String) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "verbatim", "tests": "\n   end String_To_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Unbounded_String_Array renames Placeholder.String_To_List;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python programming\")) = (To_Unbounded_String (\"python\"), To_Unbounded_String (\"programming\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"lists tuples strings\")) = (To_Unbounded_String (\"lists\"), To_Unbounded_String (\"tuples\"), To_Unbounded_String (\"strings\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"write a program\")) = (To_Unbounded_String (\"write\"), To_Unbounded_String (\"a\"), To_Unbounded_String (\"program\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_119_search", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Search (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the element that appears only once in a sorted array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Search (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "verbatim", "tests": "\n   end Search;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Search;\n\nbegin\n   pragma Assert (Candidate ((1, 1, 2, 2, 3)) = 3);\n   pragma Assert (Candidate ((1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8)) = 8);\n   pragma Assert (Candidate ((1, 2, 2, 3, 3, 4, 4)) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_11_remove_Occ", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Occ (S : Unbounded_String; Ch : Unbounded_String) return Unbounded_String;\n   -- Write a python function to remove first and last occurrence of a given character from the string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Occ (S : Unbounded_String; Ch : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Occ;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String; Ch : Unbounded_String) return Unbounded_String renames Placeholder.Remove_Occ;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"hello\"), To_Unbounded_String (\"l\")) = To_Unbounded_String (\"heo\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"abcda\"), To_Unbounded_String (\"a\")) = To_Unbounded_String (\"bcd\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"PHP\"), To_Unbounded_String (\"P\")) = To_Unbounded_String (\"H\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_120_max_product_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Max_Product_Tuple (List1 : Integer_Integer_Tuple_Array) return Integer;\n   -- Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Product_Tuple (List1 : Integer_Integer_Tuple_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Product_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Integer_Tuple_Array) return Integer renames Placeholder.Max_Product_Tuple;\n\nbegin\n   pragma Assert (Candidate (((2, 7), (2, 6), (1, 8), (4, 9))) = 36);\n   pragma Assert (Candidate (((10, 20), (15, 2), (5, 10))) = 200);\n   pragma Assert (Candidate (((11, 44), (10, 15), (20, 5), (12, 9))) = 484);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_123_amicable_numbers_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Amicable_Numbers_Sum (Limit : Integer) return Integer;\n   -- Write a function to sum all amicable numbers from 1 to a specified number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Amicable_Numbers_Sum (Limit : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Amicable_Numbers_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Limit : Integer) return Integer renames Placeholder.Amicable_Numbers_Sum;\n\nbegin\n   pragma Assert (Candidate (999) = 504);\n   pragma Assert (Candidate (9999) = 31626);\n   pragma Assert (Candidate (99) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_125_find_length", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Length (My_String : Unbounded_String) return Integer;\n   -- Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Length (My_String : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Length;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Integer renames Placeholder.Find_Length;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"11000010001\")) = 6);\n   pragma Assert (Candidate (To_Unbounded_String (\"10111\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"11011101100101\")) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_126_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sum (A : Integer; B : Integer) return Integer;\n   -- Write a python function to find the sum of common divisors of two given numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum (A : Integer; B : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Integer renames Placeholder.Sum;\n\nbegin\n   pragma Assert (Candidate (10, 15) = 6);\n   pragma Assert (Candidate (100, 150) = 93);\n   pragma Assert (Candidate (4, 6) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_127_multiply_int", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Multiply_Int (X : Integer; Y : Integer) return Integer;\n   -- Write a function to multiply two integers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Multiply_Int (X : Integer; Y : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "verbatim", "tests": "\n   end Multiply_Int;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (X : Integer; Y : Integer) return Integer renames Placeholder.Multiply_Int;\n\nbegin\n   pragma Assert (Candidate (10, 20) = 200);\n   pragma Assert (Candidate (5, 10) = 50);\n   pragma Assert (Candidate (4, 8) = 32);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_128_long_words", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Long_Words (N : Integer; Str : Unbounded_String) return Unbounded_String_Array;\n   -- Write a function to find words that are longer than n characters from a given list of words.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Long_Words (N : Integer; Str : Unbounded_String) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "verbatim", "tests": "\n   end Long_Words;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer; Str : Unbounded_String) return Unbounded_String_Array renames Placeholder.Long_Words;\n\nbegin\n   pragma Assert (Candidate (3, To_Unbounded_String (\"python is a programming language\")) = (To_Unbounded_String (\"python\"), To_Unbounded_String (\"programming\"), To_Unbounded_String (\"language\")));\n   pragma Assert (Candidate (2, To_Unbounded_String (\"writing a program\")) = (To_Unbounded_String (\"writing\"), To_Unbounded_String (\"program\")));\n   pragma Assert (Candidate (5, To_Unbounded_String (\"sorting list\")) = (0 => To_Unbounded_String (\"sorting\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_129_magic_square_test", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Magic_Square_Test (My_Matrix : Integer_Array_Array) return Boolean;\n   -- Write a function to calculate whether the matrix is a magic square.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Magic_Square_Test (My_Matrix : Integer_Array_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "verbatim", "tests": "\n   end Magic_Square_Test;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_Matrix : Integer_Array_Array) return Boolean renames Placeholder.Magic_Square_Test;\n\nbegin\n   pragma Assert (Candidate (((7, 12, 1, 14), (2, 13, 8, 11), (16, 3, 10, 5), (9, 6, 15, 4))) = True);\n   pragma Assert (Candidate (((2, 7, 6), (9, 5, 1), (4, 3, 8))) = True);\n   pragma Assert (Candidate (((2, 7, 6), (9, 5, 1), (4, 3, 7))) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_12_sort_matrix", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Sort_Matrix (M : Integer_Array_Array) return Integer_Array_Array;\n   -- Write a function to sort a given matrix in ascending order according to the sum of its rows.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sort_Matrix (M : Integer_Array_Array) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "verbatim", "tests": "\n   end Sort_Matrix;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (M : Integer_Array_Array) return Integer_Array_Array renames Placeholder.Sort_Matrix;\n\nbegin\n   pragma Assert (Candidate (((1, 2, 3), (2, 4, 5), (1, 1, 1))) = ((1, 1, 1), (1, 2, 3), (2, 4, 5)));\n   pragma Assert (Candidate (((1, 2, 3), (-2, 4, -5), (1, -1, 1))) = ((-2, 4, -5), (1, -1, 1), (1, 2, 3)));\n   pragma Assert (Candidate (((5, 8, 9), (6, 4, 3), (2, 1, 4))) = ((2, 1, 4), (6, 4, 3), (5, 8, 9)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_130_max_occurrences", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Occurrences (Nums : Integer_Array) return Integer;\n   -- Write a function to find the item with maximum frequency in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Occurrences (Nums : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Occurrences;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer renames Placeholder.Max_Occurrences;\n\nbegin\n   pragma Assert (Candidate ((2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2)) = 2);\n   pragma Assert (Candidate ((2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18)) = 8);\n   pragma Assert (Candidate ((10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10)) = 20);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_131_reverse_vowels", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Reverse_Vowels (Str1 : Unbounded_String) return Unbounded_String;\n   -- Write a python function to reverse only the vowels of a given string (where y is not a vowel).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Reverse_Vowels (Str1 : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "verbatim", "tests": "\n   end Reverse_Vowels;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String renames Placeholder.Reverse_Vowels;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Python\")) = To_Unbounded_String (\"Python\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"USA\")) = To_Unbounded_String (\"ASU\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"ab\")) = To_Unbounded_String (\"ab\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_132_tup_string", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Tup_String (Tup1 : Unbounded_String_Array) return Unbounded_String;\n   -- Write a function to convert a list to a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Tup_String (Tup1 : Unbounded_String_Array) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "verbatim", "tests": "\n   end Tup_String;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Tup1 : Unbounded_String_Array) return Unbounded_String renames Placeholder.Tup_String;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"e\"), To_Unbounded_String (\"x\"), To_Unbounded_String (\"e\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"c\"), To_Unbounded_String (\"i\"), To_Unbounded_String (\"s\"), To_Unbounded_String (\"e\"), To_Unbounded_String (\"s\"))) = To_Unbounded_String (\"exercises\"));\n   pragma Assert (Candidate ((To_Unbounded_String (\"p\"), To_Unbounded_String (\"y\"), To_Unbounded_String (\"t\"), To_Unbounded_String (\"h\"), To_Unbounded_String (\"o\"), To_Unbounded_String (\"n\"))) = To_Unbounded_String (\"python\"));\n   pragma Assert (Candidate ((To_Unbounded_String (\"p\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"o\"), To_Unbounded_String (\"g\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"a\"), To_Unbounded_String (\"m\"))) = To_Unbounded_String (\"program\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_133_sum_negativenum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Sum_Negativenum (Nums : Integer_Array) return Integer;\n   -- Write a function to calculate the sum of the negative numbers of a given list of numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Negativenum (Nums : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Negativenum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer renames Placeholder.Sum_Negativenum;\n\nbegin\n   pragma Assert (Candidate ((2, 4, -6, -9, 11, -12, 14, -5, 17)) = -32);\n   pragma Assert (Candidate ((10, 15, -14, 13, -18, 12, -20)) = -52);\n   pragma Assert (Candidate ((19, -65, 57, 39, 152, -639, 121, 44, 90, -190)) = -894);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_135_hexagonal_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Hexagonal_Num (N : Integer) return Integer;\n   -- Write a function to find the nth hexagonal number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Hexagonal_Num (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Hexagonal_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Hexagonal_Num;\n\nbegin\n   pragma Assert (Candidate (10) = 190);\n   pragma Assert (Candidate (5) = 45);\n   pragma Assert (Candidate (7) = 91);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Sum_Of_Powers_Of_Two (N : Integer) return Boolean;\n   -- Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Sum_Of_Powers_Of_Two (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Sum_Of_Powers_Of_Two;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Is_Sum_Of_Powers_Of_Two;\n\nbegin\n   pragma Assert (Candidate (10) = True);\n   pragma Assert (Candidate (7) = False);\n   pragma Assert (Candidate (14) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_141_pancake_sort", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Pancake_Sort (Nums : Integer_Array) return Integer_Array;\n   -- Write a function to sort a list of elements.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Pancake_Sort (Nums : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "verbatim", "tests": "\n   end Pancake_Sort;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer_Array renames Placeholder.Pancake_Sort;\n\nbegin\n   pragma Assert (Candidate ((15, 79, 25, 38, 69)) = (15, 25, 38, 69, 79));\n   pragma Assert (Candidate ((98, 12, 54, 36, 85)) = (12, 36, 54, 85, 98));\n   pragma Assert (Candidate ((41, 42, 32, 12, 23)) = (12, 23, 32, 41, 42));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_142_count_samepair", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Count_Samepair (List1 : Integer_Array; List2 : Integer_Array; List3 : Integer_Array) return Integer;\n   -- Write a function to count number items that are identical in the same position of three given lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Samepair (List1 : Integer_Array; List2 : Integer_Array; List3 : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Samepair;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array; List2 : Integer_Array; List3 : Integer_Array) return Integer renames Placeholder.Count_Samepair;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8), (2, 2, 3, 1, 2, 6, 7, 9), (2, 1, 3, 1, 2, 6, 7, 9)) = 3);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8), (2, 2, 3, 1, 2, 6, 7, 8), (2, 1, 3, 1, 2, 6, 7, 8)) = 4);\n   pragma Assert (Candidate ((1, 2, 3, 4, 2, 6, 7, 8), (2, 2, 3, 1, 2, 6, 7, 8), (2, 1, 3, 1, 2, 6, 7, 8)) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_145_max_Abs_Diff", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Abs_Diff (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the maximum difference between any two elements in a given array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Abs_Diff (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Abs_Diff;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Max_Abs_Diff;\n\nbegin\n   pragma Assert (Candidate ((2, 1, 5, 3)) = 4);\n   pragma Assert (Candidate ((9, 3, 2, 5, 1)) = 8);\n   pragma Assert (Candidate ((3, 2, 1)) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_14_find_Volume", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Volume (L : Integer; B : Integer; H : Integer) return Integer;\n   -- Write a python function to find the volume of a triangular prism.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Volume (L : Integer; B : Integer; H : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_14_find_Volume.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Volume;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer; B : Integer; H : Integer) return Integer renames Placeholder.Find_Volume;\n\nbegin\n   pragma Assert (Candidate (10, 8, 6) = 240);\n   pragma Assert (Candidate (3, 2, 2) = 6);\n   pragma Assert (Candidate (1, 2, 1) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_160_find_solution", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Option (Valid : Boolean := False) is record\n   case Valid is\n      when True =>\n         Value : Integer_Integer_Tuple;\n      when False =>\n         null;\n   end case;\nend record;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Find_Solution (A : Integer; B : Integer; N : Integer) return Integer_Integer_Tuple_Option;\n   -- Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Solution (A : Integer; B : Integer; N : Integer) return Integer_Integer_Tuple_Option", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Solution;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer; N : Integer) return Integer_Integer_Tuple_Option renames Placeholder.Find_Solution;\n\nbegin\n   pragma Assert (Candidate (2, 3, 7) = (Valid => True, Value => (2, 1)));\n   pragma Assert (Candidate (4, 2, 7) = (Valid => False));\n   pragma Assert (Candidate (1, 13, 17) = (Valid => True, Value => (4, 1)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_161_remove_elements", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Remove_Elements (List1 : Integer_Array; List2 : Integer_Array) return Integer_Array;\n   -- Write a function to remove all elements from a given list present in another list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Elements (List1 : Integer_Array; List2 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Elements;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array; List2 : Integer_Array) return Integer_Array renames Placeholder.Remove_Elements;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), (2, 4, 6, 8)) = (1, 3, 5, 7, 9, 10));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), (1, 3, 5, 7)) = (2, 4, 6, 8, 9, 10));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), (5, 7)) = (1, 2, 3, 4, 6, 8, 9, 10));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_162_sum_series", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sum_Series (N : Integer) return Integer;\n   -- Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Series (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Series;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Sum_Series;\n\nbegin\n   pragma Assert (Candidate (6) = 12);\n   pragma Assert (Candidate (10) = 30);\n   pragma Assert (Candidate (9) = 25);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_164_are_equivalent", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Are_Equivalent (Num1 : Integer; Num2 : Integer) return Boolean;\n   -- Write a function to determine if the sum of the divisors of two integers are the same.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Are_Equivalent (Num1 : Integer; Num2 : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_164_are_equivalent.py", "prompt_terminology": "verbatim", "tests": "\n   end Are_Equivalent;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num1 : Integer; Num2 : Integer) return Boolean renames Placeholder.Are_Equivalent;\n\nbegin\n   pragma Assert (Candidate (36, 57) = False);\n   pragma Assert (Candidate (2, 4) = False);\n   pragma Assert (Candidate (23, 47) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_165_count_char_position", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Char_Position (Str1 : Unbounded_String) return Integer;\n   -- Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Char_Position (Str1 : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Char_Position;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Integer renames Placeholder.Count_Char_Position;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"xbcefg\")) = 2);\n   pragma Assert (Candidate (To_Unbounded_String (\"ABcED\")) = 3);\n   pragma Assert (Candidate (To_Unbounded_String (\"AbgdeF\")) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_166_find_even_pair", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Even_Pair (A : Integer_Array) return Integer;\n   -- Write a function that counts the number of pairs of integers in a list that xor to an even number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Even_Pair (A : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Even_Pair;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array) return Integer renames Placeholder.Find_Even_Pair;\n\nbegin\n   pragma Assert (Candidate ((5, 4, 7, 2, 1)) = 4);\n   pragma Assert (Candidate ((7, 2, 8, 1, 0, 5, 11)) = 9);\n   pragma Assert (Candidate ((1, 2, 3)) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_167_next_power_of_2", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Next_Power_Of_2 (N : Integer) return Integer;\n   -- Write a python function to find the smallest power of 2 greater than or equal to n.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Next_Power_Of_2 (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "verbatim", "tests": "\n   end Next_Power_Of_2;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Next_Power_Of_2;\n\nbegin\n   pragma Assert (Candidate (0) = 1);\n   pragma Assert (Candidate (5) = 8);\n   pragma Assert (Candidate (17) = 32);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_168_frequency", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Frequency (A : Integer_Array; X : Integer) return Integer;\n   -- Write a function to count the number of occurrences of a number in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Frequency (A : Integer_Array; X : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_168_frequency.py", "prompt_terminology": "verbatim", "tests": "\n   end Frequency;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; X : Integer) return Integer renames Placeholder.Frequency;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3), 4) = 0);\n   pragma Assert (Candidate ((1, 2, 2, 3, 3, 3, 4), 3) = 3);\n   pragma Assert (Candidate ((0, 1, 2, 3, 1, 2), 1) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_16_text_lowercase_underscore", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Lowercase_Underscore (Text : Unbounded_String) return Boolean;\n   -- Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Lowercase_Underscore (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_16_text_lowercase_underscore.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Lowercase_Underscore;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Lowercase_Underscore;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"aab_cbbbc\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"aab_Abbbc\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"Aaab_abbbc\")) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_170_sum_range_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Sum_Range_List (List1 : Integer_Array; M : Integer; N : Integer) return Integer;\n   -- Write a function to find the sum of numbers in a list within a range specified by two indices.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Range_List (List1 : Integer_Array; M : Integer; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Range_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array; M : Integer; N : Integer) return Integer renames Placeholder.Sum_Range_List;\n\nbegin\n   pragma Assert (Candidate ((2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12), 8, 10) = 29);\n   pragma Assert (Candidate ((2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12), 5, 7) = 16);\n   pragma Assert (Candidate ((2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12), 7, 10) = 38);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_171_perimeter_pentagon", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Perimeter_Pentagon (A : Integer) return Integer;\n   -- Write a function to find the perimeter of a regular pentagon from the length of its sides.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Perimeter_Pentagon (A : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "verbatim", "tests": "\n   end Perimeter_Pentagon;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer) return Integer renames Placeholder.Perimeter_Pentagon;\n\nbegin\n   pragma Assert (Candidate (5) = 25);\n   pragma Assert (Candidate (10) = 50);\n   pragma Assert (Candidate (15) = 75);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_172_count_occurance", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Occurance (S : Unbounded_String) return Integer;\n   -- Write a function to count the number of occurence of the string 'std' in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Occurance (S : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Occurance;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String) return Integer renames Placeholder.Count_Occurance;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"letstdlenstdporstd\")) = 3);\n   pragma Assert (Candidate (To_Unbounded_String (\"truststdsolensporsd\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"makestdsostdworthit\")) = 2);\n   pragma Assert (Candidate (To_Unbounded_String (\"stds\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"\")) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_17_square_perimeter", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Square_Perimeter (A : Integer) return Integer;\n   -- Write a function that returns the perimeter of a square given its side length as input.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Square_Perimeter (A : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "verbatim", "tests": "\n   end Square_Perimeter;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer) return Integer renames Placeholder.Square_Perimeter;\n\nbegin\n   pragma Assert (Candidate (10) = 40);\n   pragma Assert (Candidate (5) = 20);\n   pragma Assert (Candidate (4) = 16);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_18_remove_dirty_chars", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Dirty_Chars (My_String : Unbounded_String; Second_String : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove characters from the first string which are present in the second string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Dirty_Chars (My_String : Unbounded_String; Second_String : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Dirty_Chars;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String; Second_String : Unbounded_String) return Unbounded_String renames Placeholder.Remove_Dirty_Chars;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"probasscurve\"), To_Unbounded_String (\"pros\")) = To_Unbounded_String (\"bacuve\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"digitalindia\"), To_Unbounded_String (\"talent\")) = To_Unbounded_String (\"digiidi\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"exoticmiles\"), To_Unbounded_String (\"toxic\")) = To_Unbounded_String (\"emles\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_19_test_duplicate", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Test_Duplicate (Arraynums : Integer_Array) return Boolean;\n   -- Write a function to find whether a given array of integers contains any duplicate element.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Test_Duplicate (Arraynums : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "verbatim", "tests": "\n   end Test_Duplicate;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arraynums : Integer_Array) return Boolean renames Placeholder.Test_Duplicate;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5)) = False);\n   pragma Assert (Candidate ((1, 2, 3, 4, 4)) = True);\n   pragma Assert (Candidate ((1, 1, 2, 2, 3, 3, 4, 4, 5)) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_20_is_woodall", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Woodall (X : Integer) return Boolean;\n   -- Write a function to check if the given number is woodball or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Woodall (X : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Woodall;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (X : Integer) return Boolean renames Placeholder.Is_Woodall;\n\nbegin\n   pragma Assert (Candidate (383) = True);\n   pragma Assert (Candidate (254) = False);\n   pragma Assert (Candidate (200) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_223_is_majority", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Is_Majority (Arr : Integer_Array; N : Integer; X : Integer) return Boolean;\n   -- Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Majority (Arr : Integer_Array; N : Integer; X : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Majority;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; N : Integer; X : Integer) return Boolean renames Placeholder.Is_Majority;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 3, 3, 3, 10), 7, 3) = True);\n   pragma Assert (Candidate ((1, 1, 2, 4, 4, 4, 6, 6), 8, 4) = False);\n   pragma Assert (Candidate ((1, 1, 1, 2, 2), 5, 1) = True);\n   pragma Assert (Candidate ((1, 1, 2, 2), 5, 1) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_224_count_Set_Bits", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Set_Bits (N : Integer) return Integer;\n   -- Write a python function to count the number of set bits (binary digits with value 1) in a given number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Set_Bits (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_224_count_Set_Bits.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Set_Bits;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Count_Set_Bits;\n\nbegin\n   pragma Assert (Candidate (2) = 1);\n   pragma Assert (Candidate (4) = 1);\n   pragma Assert (Candidate (6) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_226_odd_values_string", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Odd_Values_String (Str : Unbounded_String) return Unbounded_String;\n   -- Write a python function to remove the characters which have odd index values of a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Odd_Values_String (Str : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "verbatim", "tests": "\n   end Odd_Values_String;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String) return Unbounded_String renames Placeholder.Odd_Values_String;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"abcdef\")) = To_Unbounded_String (\"ace\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"python\")) = To_Unbounded_String (\"pto\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"data\")) = To_Unbounded_String (\"dt\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"lambs\")) = To_Unbounded_String (\"lms\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_227_min_of_three", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Min_Of_Three (A : Integer; B : Integer; C : Integer) return Integer;\n   -- Write a function to find minimum of three numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Min_Of_Three (A : Integer; B : Integer; C : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "verbatim", "tests": "\n   end Min_Of_Three;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer; C : Integer) return Integer renames Placeholder.Min_Of_Three;\n\nbegin\n   pragma Assert (Candidate (10, 20, 0) = 0);\n   pragma Assert (Candidate (19, 15, 18) = 15);\n   pragma Assert (Candidate (-10, -20, -30) = -30);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_228_all_Bits_Set_In_The_Given_Range", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function All_Bits_Set_In_The_Given_Range (N : Integer; L : Integer; R : Integer) return Boolean;\n   -- Write a python function to check whether all the bits are unset in the given range or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function All_Bits_Set_In_The_Given_Range (N : Integer; L : Integer; R : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_228_all_Bits_Set_In_The_Given_Range.py", "prompt_terminology": "verbatim", "tests": "\n   end All_Bits_Set_In_The_Given_Range;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer; L : Integer; R : Integer) return Boolean renames Placeholder.All_Bits_Set_In_The_Given_Range;\n\nbegin\n   pragma Assert (Candidate (4, 1, 2) = True);\n   pragma Assert (Candidate (17, 2, 4) = True);\n   pragma Assert (Candidate (39, 4, 6) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_229_re_arrange_array", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Re_Arrange_Array (Arr : Integer_Array; N : Integer) return Integer_Array;\n   -- Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Re_Arrange_Array (Arr : Integer_Array; N : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "verbatim", "tests": "\n   end Re_Arrange_Array;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; N : Integer) return Integer_Array renames Placeholder.Re_Arrange_Array;\n\nbegin\n   pragma Assert (Candidate ((-1, 2, -3, 4, 5, 6, -7, 8, 9), 9) = (-1, -3, -7, 4, 5, 6, 2, 8, 9));\n   pragma Assert (Candidate ((12, -14, -26, 13, 15), 5) = (-14, -26, 12, 13, 15));\n   pragma Assert (Candidate ((10, 24, 36, -42, -39, -78, 85), 7) = (-42, -39, -78, 10, 24, 36, 85));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_230_replace_blank", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Replace_Blank (Str1 : Unbounded_String; Char : Unbounded_String) return Unbounded_String;\n   -- Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Replace_Blank (Str1 : Unbounded_String; Char : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "verbatim", "tests": "\n   end Replace_Blank;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String; Char : Unbounded_String) return Unbounded_String renames Placeholder.Replace_Blank;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"hello people\"), To_Unbounded_String (\"@\")) = To_Unbounded_String (\"hello@people\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"python program language\"), To_Unbounded_String (\"$\")) = To_Unbounded_String (\"python$program$language\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"blank space\"), To_Unbounded_String (\"-\")) = To_Unbounded_String (\"blank-space\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_234_volume_cube", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Volume_Cube (L : Integer) return Integer;\n   -- Write a function to find the volume of a cube given its side length.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Volume_Cube (L : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_234_volume_cube.py", "prompt_terminology": "verbatim", "tests": "\n   end Volume_Cube;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer) return Integer renames Placeholder.Volume_Cube;\n\nbegin\n   pragma Assert (Candidate (3) = 27);\n   pragma Assert (Candidate (2) = 8);\n   pragma Assert (Candidate (5) = 125);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_238_number_of_substrings", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Number_Of_Substrings (Str : Unbounded_String) return Integer;\n   -- Write a python function to count the number of non-empty substrings of a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Number_Of_Substrings (Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py", "prompt_terminology": "verbatim", "tests": "\n   end Number_Of_Substrings;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String) return Integer renames Placeholder.Number_Of_Substrings;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"abc\")) = 6);\n   pragma Assert (Candidate (To_Unbounded_String (\"abcd\")) = 10);\n   pragma Assert (Candidate (To_Unbounded_String (\"abcde\")) = 15);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_239_get_total_number_of_sequences", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Get_Total_Number_Of_Sequences (M : Integer; N : Integer) return Integer;\n   -- Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Total_Number_Of_Sequences (M : Integer; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Total_Number_Of_Sequences;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (M : Integer; N : Integer) return Integer renames Placeholder.Get_Total_Number_Of_Sequences;\n\nbegin\n   pragma Assert (Candidate (10, 4) = 4);\n   pragma Assert (Candidate (5, 2) = 6);\n   pragma Assert (Candidate (16, 3) = 84);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_242_count_charac", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Charac (Str1 : Unbounded_String) return Integer;\n   -- Write a function to count the total number of characters in a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Charac (Str1 : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_242_count_charac.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Charac;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Integer renames Placeholder.Count_Charac;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python programming\")) = 18);\n   pragma Assert (Candidate (To_Unbounded_String (\"language\")) = 8);\n   pragma Assert (Candidate (To_Unbounded_String (\"words\")) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_244_next_Perfect_Square", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Next_Perfect_Square (N : Integer) return Integer;\n   -- Write a python function to find the next perfect square greater than a given number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Next_Perfect_Square (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py", "prompt_terminology": "verbatim", "tests": "\n   end Next_Perfect_Square;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Next_Perfect_Square;\n\nbegin\n   pragma Assert (Candidate (35) = 36);\n   pragma Assert (Candidate (6) = 9);\n   pragma Assert (Candidate (9) = 16);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_245_max_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Sum (Arr : Integer_Array) return Integer;\n   -- Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Sum (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Max_Sum;\n\nbegin\n   pragma Assert (Candidate ((1, 15, 51, 45, 33, 100, 12, 18, 9)) = 194);\n   pragma Assert (Candidate ((80, 60, 30, 40, 20, 10)) = 210);\n   pragma Assert (Candidate ((2, 3, 14, 16, 21, 23, 29, 30)) = 138);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_247_lps", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Lps (Str : Unbounded_String) return Integer;\n   -- Write a function to find the length of the longest palindromic subsequence in the given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Lps (Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "verbatim", "tests": "\n   end Lps;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String) return Integer renames Placeholder.Lps;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"TENS FOR TENS\")) = 5);\n   pragma Assert (Candidate (To_Unbounded_String (\"CARDIO FOR CARDS\")) = 7);\n   pragma Assert (Candidate (To_Unbounded_String (\"PART OF THE JOURNEY IS PART\")) = 9);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_249_intersection_array", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Intersection_Array (Array_Nums1 : Integer_Array; Array_Nums2 : Integer_Array) return Integer_Array;\n   -- Write a function to find the intersection of two arrays.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Intersection_Array (Array_Nums1 : Integer_Array; Array_Nums2 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "verbatim", "tests": "\n   end Intersection_Array;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Array_Nums1 : Integer_Array; Array_Nums2 : Integer_Array) return Integer_Array renames Placeholder.Intersection_Array;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 5, 7, 8, 9, 10), (1, 2, 4, 8, 9)) = (1, 2, 8, 9));\n   pragma Assert (Candidate ((1, 2, 3, 5, 7, 8, 9, 10), (3, 5, 7, 9)) = (3, 5, 7, 9));\n   pragma Assert (Candidate ((1, 2, 3, 5, 7, 8, 9, 10), (10, 20, 30, 40)) = (0 => 10));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_250_count_X", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Count_X (Tup : Integer_Array; X : Integer) return Integer;\n   -- Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_X (Tup : Integer_Array; X : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_X;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Tup : Integer_Array; X : Integer) return Integer renames Placeholder.Count_X;\n\nbegin\n   pragma Assert (Candidate ((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 4) = 0);\n   pragma Assert (Candidate ((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 10) = 3);\n   pragma Assert (Candidate ((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2), 8) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_251_insert_element", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Insert_Element (List : Unbounded_String_Array; Element : Unbounded_String) return Unbounded_String_Array;\n   -- Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Insert_Element (List : Unbounded_String_Array; Element : Unbounded_String) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "verbatim", "tests": "\n   end Insert_Element;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List : Unbounded_String_Array; Element : Unbounded_String) return Unbounded_String_Array renames Placeholder.Insert_Element;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Black\")), To_Unbounded_String (\"c\")) = (To_Unbounded_String (\"c\"), To_Unbounded_String (\"Red\"), To_Unbounded_String (\"c\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"c\"), To_Unbounded_String (\"Black\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"python\"), To_Unbounded_String (\"java\")), To_Unbounded_String (\"program\")) = (To_Unbounded_String (\"program\"), To_Unbounded_String (\"python\"), To_Unbounded_String (\"program\"), To_Unbounded_String (\"java\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"happy\"), To_Unbounded_String (\"sad\")), To_Unbounded_String (\"laugh\")) = (To_Unbounded_String (\"laugh\"), To_Unbounded_String (\"happy\"), To_Unbounded_String (\"laugh\"), To_Unbounded_String (\"sad\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_252_convert", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Float_Float_Tuple is record\n     Float_1 : Float;\n     Float_2 : Float;\n   end record;\n\n   function Convert (Numbers : Integer) return Float_Float_Tuple;\n   -- Write a python function to convert complex numbers to polar coordinates.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Convert (Numbers : Integer) return Float_Float_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "verbatim", "tests": "\n   end Convert;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Numbers : Integer) return Float_Float_Tuple renames Placeholder.Convert;\n\nbegin\n   pragma Assert (Candidate (1) = (1.0, 0.0));\n   pragma Assert (Candidate (4) = (4.0, 0.0));\n   pragma Assert (Candidate (5) = (5.0, 0.0));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_255_combinations_colors", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   type Unbounded_String_Array_Array is array (Integer range <>) of Unbounded_String_Array;\n   function Combinations_Colors (L : Unbounded_String_Array; N : Integer) return Unbounded_String_Array_Array;\n   -- Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Combinations_Colors (L : Unbounded_String_Array; N : Integer) return Unbounded_String_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "verbatim", "tests": "\n   end Combinations_Colors;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Unbounded_String_Array; N : Integer) return Unbounded_String_Array_Array renames Placeholder.Combinations_Colors;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\")), 1) = ((0 => To_Unbounded_String (\"Red\")), (0 => To_Unbounded_String (\"Green\")), (0 => To_Unbounded_String (\"Blue\"))));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\")), 2) = ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Red\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Green\")), (To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Blue\"), To_Unbounded_String (\"Blue\"))));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\")), 3) = ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Red\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Green\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Blue\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Green\")), (To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\"), To_Unbounded_String (\"Blue\")), (To_Unbounded_String (\"Blue\"), To_Unbounded_String (\"Blue\"), To_Unbounded_String (\"Blue\"))));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_256_count_Primes_nums", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Primes_Nums (N : Integer) return Integer;\n   -- Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Primes_Nums (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Primes_Nums;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Count_Primes_Nums;\n\nbegin\n   pragma Assert (Candidate (5) = 2);\n   pragma Assert (Candidate (10) = 4);\n   pragma Assert (Candidate (100) = 25);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_257_swap_numbers", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Swap_Numbers (A : Integer; B : Integer) return Integer_Array;\n   -- Write a function that takes in two numbers and returns a list with the second number and then the first number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Swap_Numbers (A : Integer; B : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "verbatim", "tests": "\n   end Swap_Numbers;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Integer_Array renames Placeholder.Swap_Numbers;\n\nbegin\n   pragma Assert (Candidate (10, 20) = (20, 10));\n   pragma Assert (Candidate (15, 17) = (17, 15));\n   pragma Assert (Candidate (100, 200) = (200, 100));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_259_maximize_elements", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Maximize_Elements (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array;\n   -- Write a function to maximize the given two lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Maximize_Elements (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_259_maximize_elements.py", "prompt_terminology": "verbatim", "tests": "\n   end Maximize_Elements;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array renames Placeholder.Maximize_Elements;\n\nbegin\n   pragma Assert (Candidate (((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) = ((6, 7), (4, 9), (2, 9), (7, 10)));\n   pragma Assert (Candidate (((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) = ((7, 8), (5, 10), (3, 10), (8, 11)));\n   pragma Assert (Candidate (((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) = ((8, 9), (6, 11), (4, 11), (9, 12)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_260_newman_prime", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Newman_Prime (N : Integer) return Integer;\n   -- Write a function to find the nth newman\u2013shanks\u2013williams prime number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Newman_Prime (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "verbatim", "tests": "\n   end Newman_Prime;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Newman_Prime;\n\nbegin\n   pragma Assert (Candidate (3) = 7);\n   pragma Assert (Candidate (4) = 17);\n   pragma Assert (Candidate (5) = 41);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_261_division_elements", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n   end record;\n\n   function Division_Elements (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Division_Elements (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_261_division_elements.py", "prompt_terminology": "verbatim", "tests": "\n   end Division_Elements;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple renames Placeholder.Division_Elements;\n\nbegin\n   pragma Assert (Candidate ((10, 4, 6, 9), (5, 2, 3, 3)) = (2, 2, 2, 3));\n   pragma Assert (Candidate ((12, 6, 8, 16), (6, 3, 4, 4)) = (2, 2, 2, 4));\n   pragma Assert (Candidate ((20, 14, 36, 18), (5, 7, 6, 9)) = (4, 2, 6, 2));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_264_dog_age", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Dog_Age (H_Age : Integer) return Integer;\n   -- Write a function to calculate a dog's age in dog's years.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Dog_Age (H_Age : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "verbatim", "tests": "\n   end Dog_Age;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (H_Age : Integer) return Integer renames Placeholder.Dog_Age;\n\nbegin\n   pragma Assert (Candidate (12) = 61);\n   pragma Assert (Candidate (15) = 73);\n   pragma Assert (Candidate (24) = 109);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_266_lateralsurface_cube", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Lateralsurface_Cube (L : Integer) return Integer;\n   -- Write a function to find the lateral surface area of a cube given its side length.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Lateralsurface_Cube (L : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_266_lateralsurface_cube.py", "prompt_terminology": "verbatim", "tests": "\n   end Lateralsurface_Cube;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer) return Integer renames Placeholder.Lateralsurface_Cube;\n\nbegin\n   pragma Assert (Candidate (5) = 100);\n   pragma Assert (Candidate (9) = 324);\n   pragma Assert (Candidate (10) = 400);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_267_square_Sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Square_Sum (N : Integer) return Integer;\n   -- Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Square_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_267_square_Sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Square_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Square_Sum;\n\nbegin\n   pragma Assert (Candidate (2) = 10);\n   pragma Assert (Candidate (3) = 35);\n   pragma Assert (Candidate (4) = 84);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_268_find_star_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Star_Num (N : Integer) return Integer;\n   -- Write a function to find the n'th star number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Star_Num (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Star_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Find_Star_Num;\n\nbegin\n   pragma Assert (Candidate (3) = 37);\n   pragma Assert (Candidate (4) = 73);\n   pragma Assert (Candidate (5) = 121);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_269_ascii_value", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Ascii_Value (K : Unbounded_String) return Integer;\n   -- Write a function to find the ascii value of a character.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Ascii_Value (K : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "verbatim", "tests": "\n   end Ascii_Value;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (K : Unbounded_String) return Integer renames Placeholder.Ascii_Value;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"A\")) = 65);\n   pragma Assert (Candidate (To_Unbounded_String (\"R\")) = 82);\n   pragma Assert (Candidate (To_Unbounded_String (\"S\")) = 83);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_270_sum_even_and_even_index", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Sum_Even_And_Even_Index (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the sum of even numbers at even positions of a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Even_And_Even_Index (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Even_And_Even_Index;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Sum_Even_And_Even_Index;\n\nbegin\n   pragma Assert (Candidate ((5, 6, 12, 1, 18, 8)) = 30);\n   pragma Assert (Candidate ((3, 20, 17, 9, 2, 10, 18, 13, 6, 18)) = 26);\n   pragma Assert (Candidate ((5, 6, 12, 1)) = 12);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_271_even_Power_Sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Even_Power_Sum (N : Integer) return Integer;\n   -- Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Even_Power_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_271_even_Power_Sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Even_Power_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Even_Power_Sum;\n\nbegin\n   pragma Assert (Candidate (2) = 1056);\n   pragma Assert (Candidate (3) = 8832);\n   pragma Assert (Candidate (1) = 32);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_272_rear_extract", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Unbounded_String_Integer_Tuple_Array is array (Integer range <>) of Integer_Unbounded_String_Integer_Tuple;\n   type Integer_Unbounded_String_Integer_Tuple is record\n     Integer_1 : Integer;\n     Unbounded_String_2 : Unbounded_String;\n     Integer_3 : Integer;\n   end record;\n\n   function Rear_Extract (Test_List : Integer_Unbounded_String_Integer_Tuple_Array) return Integer_Array;\n   -- Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Rear_Extract (Test_List : Integer_Unbounded_String_Integer_Tuple_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "verbatim", "tests": "\n   end Rear_Extract;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Unbounded_String_Integer_Tuple_Array) return Integer_Array renames Placeholder.Rear_Extract;\n\nbegin\n   pragma Assert (Candidate (((1, To_Unbounded_String (\"Rash\"), 21), (2, To_Unbounded_String (\"Varsha\"), 20), (3, To_Unbounded_String (\"Kil\"), 19))) = (21, 20, 19));\n   pragma Assert (Candidate (((1, To_Unbounded_String (\"Sai\"), 36), (2, To_Unbounded_String (\"Ayesha\"), 25), (3, To_Unbounded_String (\"Salman\"), 45))) = (36, 25, 45));\n   pragma Assert (Candidate (((1, To_Unbounded_String (\"Sudeep\"), 14), (2, To_Unbounded_String (\"Vandana\"), 36), (3, To_Unbounded_String (\"Dawood\"), 56))) = (14, 36, 56));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_273_substract_elements", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Substract_Elements (Test_Tup1 : Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Tuple;\n   -- Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Substract_Elements (Test_Tup1 : Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "verbatim", "tests": "\n   end Substract_Elements;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Tuple renames Placeholder.Substract_Elements;\n\nbegin\n   pragma Assert (Candidate ((10, 4, 5), (2, 5, 18)) = (8, -1, -13));\n   pragma Assert (Candidate ((11, 2, 3), (24, 45, 16)) = (-13, -43, -13));\n   pragma Assert (Candidate ((7, 18, 9), (10, 11, 12)) = (-3, 7, -3));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_274_even_binomial_Coeff_Sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Even_Binomial_Coeff_Sum (N : Integer) return Integer;\n   -- Write a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Even_Binomial_Coeff_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_274_even_binomial_Coeff_Sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Even_Binomial_Coeff_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Even_Binomial_Coeff_Sum;\n\nbegin\n   pragma Assert (Candidate (4) = 8);\n   pragma Assert (Candidate (6) = 32);\n   pragma Assert (Candidate (2) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_279_is_num_decagonal", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Num_Decagonal (N : Integer) return Integer;\n   -- Write a function to find the nth decagonal number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Num_Decagonal (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Num_Decagonal;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Is_Num_Decagonal;\n\nbegin\n   pragma Assert (Candidate (3) = 27);\n   pragma Assert (Candidate (7) = 175);\n   pragma Assert (Candidate (10) = 370);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_280_sequential_search", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Boolean_Integer_Tuple is record\n     Boolean_1 : Boolean;\n     Integer_2 : Integer;\n   end record;\n\n   function Sequential_Search (Dlist : Integer_Array; Item : Integer) return Boolean_Integer_Tuple;\n   -- Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sequential_Search (Dlist : Integer_Array; Item : Integer) return Boolean_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "verbatim", "tests": "\n   end Sequential_Search;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Dlist : Integer_Array; Item : Integer) return Boolean_Integer_Tuple renames Placeholder.Sequential_Search;\n\nbegin\n   pragma Assert (Candidate ((11, 23, 58, 31, 56, 77, 43, 12, 65, 19), 31) = (True, 3));\n   pragma Assert (Candidate ((12, 32, 45, 62, 35, 47, 44, 61), 61) = (True, 7));\n   pragma Assert (Candidate ((9, 10, 17, 19, 22, 39, 48, 56), 48) = (True, 6));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_281_all_unique", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function All_Unique (Test_List : Integer_Array) return Boolean;\n   -- Write a python function to check if the elements of a given list are unique or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function All_Unique (Test_List : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "verbatim", "tests": "\n   end All_Unique;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Array) return Boolean renames Placeholder.All_Unique;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = True);\n   pragma Assert (Candidate ((1, 2, 1, 2)) = False);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5)) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_282_sub_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Sub_List (Nums1 : Integer_Array; Nums2 : Integer_Array) return Integer_Array;\n   -- Write a function to subtract two lists element-wise.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sub_List (Nums1 : Integer_Array; Nums2 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Sub_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums1 : Integer_Array; Nums2 : Integer_Array) return Integer_Array renames Placeholder.Sub_List;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3), (4, 5, 6)) = (-3, -3, -3));\n   pragma Assert (Candidate ((1, 2), (3, 4)) = (-2, -2));\n   pragma Assert (Candidate ((90, 120), (50, 70)) = (40, 50));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_283_validate", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Validate (N : Integer) return Boolean;\n   -- Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Validate (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "verbatim", "tests": "\n   end Validate;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Validate;\n\nbegin\n   pragma Assert (Candidate (1234) = True);\n   pragma Assert (Candidate (51241) = False);\n   pragma Assert (Candidate (321) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_285_text_match_two_three", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Match_Two_Three (Text : Unbounded_String) return Boolean;\n   -- Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Match_Two_Three (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Match_Two_Three;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Match_Two_Three;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"ac\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"dc\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"abbbba\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Sub_Array_Sum_Repeated (A : Integer_Array; N : Integer; K : Integer) return Integer;\n   -- Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Sub_Array_Sum_Repeated (A : Integer_Array; N : Integer; K : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Sub_Array_Sum_Repeated;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; N : Integer; K : Integer) return Integer renames Placeholder.Max_Sub_Array_Sum_Repeated;\n\nbegin\n   pragma Assert (Candidate ((10, 20, -30, -1), 4, 3) = 30);\n   pragma Assert (Candidate ((-1, 10, 20), 3, 2) = 59);\n   pragma Assert (Candidate ((-1, -2, -3), 3, 3) = -1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_287_square_Sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Square_Sum (N : Integer) return Integer;\n   -- Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Square_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_287_square_Sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Square_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Square_Sum;\n\nbegin\n   pragma Assert (Candidate (2) = 20);\n   pragma Assert (Candidate (3) = 56);\n   pragma Assert (Candidate (4) = 120);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_290_max_length", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Array_Tuple is record\n     Integer_1 : Integer;\n     Integer_Array_2 : Integer_Array;\n   end record;\n\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Max_Length (List1 : Integer_Array_Array) return Integer_Integer_Array_Tuple;\n   -- Write a function to find the list of maximum length in a list of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Length (List1 : Integer_Array_Array) return Integer_Integer_Array_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_290_max_length.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Length;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array_Array) return Integer_Integer_Array_Tuple renames Placeholder.Max_Length;\n\nbegin\n   pragma Assert (Candidate (((0 => 0), (1, 3), (5, 7), (9, 11), (13, 15, 17))) = (3, (13, 15, 17)));\n   pragma Assert (Candidate (((0 => 1), (5, 7), (10, 12, 14, 15))) = (4, (10, 12, 14, 15)));\n   pragma Assert (Candidate (((0 => 5), (15, 20, 25))) = (3, (15, 20, 25)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_291_count_no_of_ways", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_No_Of_Ways (N : Integer; K : Integer) return Integer;\n   -- Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_No_Of_Ways (N : Integer; K : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_No_Of_Ways;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer; K : Integer) return Integer renames Placeholder.Count_No_Of_Ways;\n\nbegin\n   pragma Assert (Candidate (2, 4) = 16);\n   pragma Assert (Candidate (3, 2) = 6);\n   pragma Assert (Candidate (4, 4) = 228);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_292_find", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find (N : Integer; M : Integer) return Integer;\n   -- Write a python function to find quotient of two numbers (rounded down to the nearest integer).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find (N : Integer; M : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "verbatim", "tests": "\n   end Find;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer; M : Integer) return Integer renames Placeholder.Find;\n\nbegin\n   pragma Assert (Candidate (10, 3) = 3);\n   pragma Assert (Candidate (4, 2) = 2);\n   pragma Assert (Candidate (20, 5) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_293_otherside_rightangle", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Otherside_Rightangle (W : Integer; H : Integer) return Float;\n   -- Write a function to find the third side of a right angled triangle.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Otherside_Rightangle (W : Integer; H : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "verbatim", "tests": "\n   end Otherside_Rightangle;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (W : Integer; H : Integer) return Float renames Placeholder.Otherside_Rightangle;\n\nbegin\n   pragma Assert (Candidate (7, 8) = 10.63014581273465);\n   pragma Assert (Candidate (3, 4) = 5);\n   pragma Assert (Candidate (7, 15) = 16.55294535724685);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_295_sum_div", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sum_Div (Number : Integer) return Integer;\n   -- Write a function to return the sum of all divisors of a number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Div (Number : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Div;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Number : Integer) return Integer renames Placeholder.Sum_Div;\n\nbegin\n   pragma Assert (Candidate (8) = 7);\n   pragma Assert (Candidate (12) = 16);\n   pragma Assert (Candidate (7) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_296_get_Inv_Count", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Get_Inv_Count (Arr : Integer_Array) return Integer;\n   -- Write a python function to count inversions in an array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Inv_Count (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Inv_Count;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Get_Inv_Count;\n\nbegin\n   pragma Assert (Candidate ((1, 20, 6, 4, 5)) = 5);\n   pragma Assert (Candidate ((1, 2, 1)) = 1);\n   pragma Assert (Candidate ((1, 2, 5, 6, 1)) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_299_max_aggregate", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Integer_Tuple_Array is array (Integer range <>) of Unbounded_String_Integer_Tuple;\n   type Unbounded_String_Integer_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Integer_2 : Integer;\n   end record;\n\n   function Max_Aggregate (Stdata : Unbounded_String_Integer_Tuple_Array) return Unbounded_String_Integer_Tuple;\n   -- Write a function to calculate the maximum aggregate from the list of tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Aggregate (Stdata : Unbounded_String_Integer_Tuple_Array) return Unbounded_String_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Aggregate;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Stdata : Unbounded_String_Integer_Tuple_Array) return Unbounded_String_Integer_Tuple renames Placeholder.Max_Aggregate;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"Juan Whelan\"), 90), (To_Unbounded_String (\"Sabah Colley\"), 88), (To_Unbounded_String (\"Peter Nichols\"), 7), (To_Unbounded_String (\"Juan Whelan\"), 122), (To_Unbounded_String (\"Sabah Colley\"), 84))) = (To_Unbounded_String (\"Juan Whelan\"), 212));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Juan Whelan\"), 50), (To_Unbounded_String (\"Sabah Colley\"), 48), (To_Unbounded_String (\"Peter Nichols\"), 37), (To_Unbounded_String (\"Juan Whelan\"), 22), (To_Unbounded_String (\"Sabah Colley\"), 14))) = (To_Unbounded_String (\"Juan Whelan\"), 72));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Juan Whelan\"), 10), (To_Unbounded_String (\"Sabah Colley\"), 20), (To_Unbounded_String (\"Peter Nichols\"), 30), (To_Unbounded_String (\"Juan Whelan\"), 40), (To_Unbounded_String (\"Sabah Colley\"), 50))) = (To_Unbounded_String (\"Sabah Colley\"), 70));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_304_find_Element", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Find_Element (Arr : Integer_Array; Ranges : Integer_Array_Array; Rotations : Integer; Index : Integer) return Integer;\n   -- Write a python function to find element at a given index after number of rotations.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Element (Arr : Integer_Array; Ranges : Integer_Array_Array; Rotations : Integer; Index : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Element;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; Ranges : Integer_Array_Array; Rotations : Integer; Index : Integer) return Integer renames Placeholder.Find_Element;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5), ((0, 2), (0, 3)), 2, 1) = 3);\n   pragma Assert (Candidate ((1, 2, 3, 4), ((0, 1), (0, 2)), 1, 2) = 3);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6), ((0, 1), (0, 2)), 1, 1) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_305_start_withp", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Unbounded_String_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Unbounded_String_2 : Unbounded_String;\n   end record;\n\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Start_Withp (Words : Unbounded_String_Array) return Unbounded_String_Unbounded_String_Tuple;\n   -- Write a function to return two words from a list of words starting with letter 'p'.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Start_Withp (Words : Unbounded_String_Array) return Unbounded_String_Unbounded_String_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_305_start_withp.py", "prompt_terminology": "verbatim", "tests": "\n   end Start_Withp;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Words : Unbounded_String_Array) return Unbounded_String_Unbounded_String_Tuple renames Placeholder.Start_Withp;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"Python PHP\"), To_Unbounded_String (\"Java JavaScript\"), To_Unbounded_String (\"c c++\"))) = (To_Unbounded_String (\"Python\"), To_Unbounded_String (\"PHP\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Python Programming\"), To_Unbounded_String (\"Java Programming\"))) = (To_Unbounded_String (\"Python\"), To_Unbounded_String (\"Programming\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Pqrst Pqr\"), To_Unbounded_String (\"qrstuv\"))) = (To_Unbounded_String (\"Pqrst\"), To_Unbounded_String (\"Pqr\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Sum_Increasing_Subseq (A : Integer_Array; N : Integer; Index : Integer; K : Integer) return Integer;\n   -- Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Sum_Increasing_Subseq (A : Integer_Array; N : Integer; Index : Integer; K : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Sum_Increasing_Subseq;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; N : Integer; Index : Integer; K : Integer) return Integer renames Placeholder.Max_Sum_Increasing_Subseq;\n\nbegin\n   pragma Assert (Candidate ((1, 101, 2, 3, 100, 4, 5), 7, 4, 6) = 11);\n   pragma Assert (Candidate ((1, 101, 2, 3, 100, 4, 5), 7, 2, 5) = 7);\n   pragma Assert (Candidate ((11, 15, 19, 21, 26, 28, 31), 7, 2, 4) = 71);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_308_large_product", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Large_Product (Nums1 : Integer_Array; Nums2 : Integer_Array; N : Integer) return Integer_Array;\n   -- Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Large_Product (Nums1 : Integer_Array; Nums2 : Integer_Array; N : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "verbatim", "tests": "\n   end Large_Product;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums1 : Integer_Array; Nums2 : Integer_Array; N : Integer) return Integer_Array renames Placeholder.Large_Product;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6), (3, 6, 8, 9, 10, 6), 3) = (60, 54, 50));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6), (3, 6, 8, 9, 10, 6), 4) = (60, 54, 50, 48));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6), (3, 6, 8, 9, 10, 6), 5) = (60, 54, 50, 48, 45));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_309_maximum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Maximum (A : Integer; B : Integer) return Integer;\n   -- Write a python function to find the maximum of two numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Maximum (A : Integer; B : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "verbatim", "tests": "\n   end Maximum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Integer renames Placeholder.Maximum;\n\nbegin\n   pragma Assert (Candidate (5, 10) = 10);\n   pragma Assert (Candidate (-1, -2) = -1);\n   pragma Assert (Candidate (9, 7) = 9);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_310_string_to_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function String_To_Tuple (Str1 : Unbounded_String) return Unbounded_String_Array;\n   -- Write a function to convert a given string to a list of characters.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function String_To_Tuple (Str1 : Unbounded_String) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_310_string_to_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end String_To_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String_Array renames Placeholder.String_To_Tuple;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python 3.0\")) = (To_Unbounded_String (\"p\"), To_Unbounded_String (\"y\"), To_Unbounded_String (\"t\"), To_Unbounded_String (\"h\"), To_Unbounded_String (\"o\"), To_Unbounded_String (\"n\"), To_Unbounded_String (\"3\"), To_Unbounded_String (\".\"), To_Unbounded_String (\"0\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"item1\")) = (To_Unbounded_String (\"i\"), To_Unbounded_String (\"t\"), To_Unbounded_String (\"e\"), To_Unbounded_String (\"m\"), To_Unbounded_String (\"1\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"15.10\")) = (To_Unbounded_String (\"1\"), To_Unbounded_String (\"5\"), To_Unbounded_String (\".\"), To_Unbounded_String (\"1\"), To_Unbounded_String (\"0\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_388_highest_Power_of_2", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Highest_Power_Of_2 (N : Integer) return Integer;\n   -- Write a python function to find the highest power of 2 that is less than or equal to n.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Highest_Power_Of_2 (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "verbatim", "tests": "\n   end Highest_Power_Of_2;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Highest_Power_Of_2;\n\nbegin\n   pragma Assert (Candidate (10) = 8);\n   pragma Assert (Candidate (19) = 16);\n   pragma Assert (Candidate (32) = 32);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_389_find_lucas", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Lucas (N : Integer) return Integer;\n   -- Write a function to find the n'th lucas number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Lucas (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Lucas;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Find_Lucas;\n\nbegin\n   pragma Assert (Candidate (9) = 76);\n   pragma Assert (Candidate (4) = 7);\n   pragma Assert (Candidate (3) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_392_get_max_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Get_Max_Sum (N : Integer) return Integer;\n   -- Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Max_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Max_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Get_Max_Sum;\n\nbegin\n   pragma Assert (Candidate (60) = 106);\n   pragma Assert (Candidate (10) = 12);\n   pragma Assert (Candidate (2) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_393_max_length_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Array_Tuple is record\n     Integer_1 : Integer;\n     Integer_Array_2 : Integer_Array;\n   end record;\n\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Max_Length_List (Input_List : Integer_Array_Array) return Integer_Integer_Array_Tuple;\n   -- Write a function to find the list with maximum length.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Length_List (Input_List : Integer_Array_Array) return Integer_Integer_Array_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Length_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Input_List : Integer_Array_Array) return Integer_Integer_Array_Tuple renames Placeholder.Max_Length_List;\n\nbegin\n   pragma Assert (Candidate (((0 => 0), (1, 3), (5, 7), (9, 11), (13, 15, 17))) = (3, (13, 15, 17)));\n   pragma Assert (Candidate (((1, 2, 3, 4, 5), (1, 2, 3, 4), (1, 2, 3), (1, 2), (0 => 1))) = (5, (1, 2, 3, 4, 5)));\n   pragma Assert (Candidate (((3, 4, 5), (6, 7, 8, 9), (10, 11, 12))) = (4, (6, 7, 8, 9)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_394_check_distinct", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Check_Distinct (Test_Tup : Integer_Array) return Boolean;\n   -- Write a function to check if given list contains no duplicates.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Distinct (Test_Tup : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Distinct;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup : Integer_Array) return Boolean renames Placeholder.Check_Distinct;\n\nbegin\n   pragma Assert (Candidate ((1, 4, 5, 6, 1, 4)) = False);\n   pragma Assert (Candidate ((1, 4, 5, 6)) = True);\n   pragma Assert (Candidate ((2, 3, 4, 5, 6)) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_395_first_non_repeating_character", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Option (Valid : Boolean := False) is record\n   case Valid is\n      when True =>\n         Value : Unbounded_String;\n      when False =>\n         null;\n   end case;\nend record;\n   function First_Non_Repeating_Character (Str1 : Unbounded_String) return Unbounded_String_Option;\n   -- Write a python function to find the first non-repeated character in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function First_Non_Repeating_Character (Str1 : Unbounded_String) return Unbounded_String_Option", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "verbatim", "tests": "\n   end First_Non_Repeating_Character;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String_Option renames Placeholder.First_Non_Repeating_Character;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"abcabc\")) = (Valid => False));\n   pragma Assert (Candidate (To_Unbounded_String (\"abc\")) = (Valid => True, Value => To_Unbounded_String (\"a\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"ababc\")) = (Valid => True, Value => To_Unbounded_String (\"c\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_396_check_char", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Check_Char (My_String : Unbounded_String) return Unbounded_String;\n   -- Write a function to check whether the given string starts and ends with the same character or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Char (My_String : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Char;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Unbounded_String renames Placeholder.Check_Char;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"abba\")) = To_Unbounded_String (\"Valid\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"a\")) = To_Unbounded_String (\"Valid\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"abcd\")) = To_Unbounded_String (\"Invalid\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_397_median_numbers", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Median_Numbers (A : Integer; B : Integer; C : Integer) return Float;\n   -- Write a function to find the median of three numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Median_Numbers (A : Integer; B : Integer; C : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "verbatim", "tests": "\n   end Median_Numbers;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer; C : Integer) return Float renames Placeholder.Median_Numbers;\n\nbegin\n   pragma Assert (Candidate (25, 55, 65) = 55.0);\n   pragma Assert (Candidate (20, 10, 30) = 20.0);\n   pragma Assert (Candidate (15, 45, 75) = 45.0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_399_bitwise_xor", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n   end record;\n\n   function Bitwise_Xor (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function to perform the mathematical bitwise xor operation across the given tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Bitwise_Xor (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "verbatim", "tests": "\n   end Bitwise_Xor;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple renames Placeholder.Bitwise_Xor;\n\nbegin\n   pragma Assert (Candidate ((10, 4, 6, 9), (5, 2, 3, 3)) = (15, 6, 5, 10));\n   pragma Assert (Candidate ((11, 5, 7, 10), (6, 3, 4, 4)) = (13, 6, 3, 14));\n   pragma Assert (Candidate ((12, 6, 8, 11), (7, 4, 5, 6)) = (11, 2, 13, 13));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_3_is_not_prime", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Not_Prime (N : Integer) return Boolean;\n   -- Write a python function to identify non-prime numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Not_Prime (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_3_is_not_prime.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Not_Prime;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Is_Not_Prime;\n\nbegin\n   pragma Assert (Candidate (2) = False);\n   pragma Assert (Candidate (10) = True);\n   pragma Assert (Candidate (35) = True);\n   pragma Assert (Candidate (37) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_400_extract_freq", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Extract_Freq (Test_List : Integer_Integer_Tuple_Array) return Integer;\n   -- Write a function to extract the number of unique tuples in the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Extract_Freq (Test_List : Integer_Integer_Tuple_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "verbatim", "tests": "\n   end Extract_Freq;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Integer_Tuple_Array) return Integer renames Placeholder.Extract_Freq;\n\nbegin\n   pragma Assert (Candidate (((3, 4), (1, 2), (4, 3), (5, 6))) = 3);\n   pragma Assert (Candidate (((4, 15), (2, 3), (5, 4), (6, 7))) = 4);\n   pragma Assert (Candidate (((5, 16), (2, 3), (6, 5), (6, 9))) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_401_add_nested_tuples", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Add_Nested_Tuples (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array;\n   -- Write a function to perform index wise addition of list elements in the given two nested lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Add_Nested_Tuples (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "verbatim", "tests": "\n   end Add_Nested_Tuples;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array renames Placeholder.Add_Nested_Tuples;\n\nbegin\n   pragma Assert (Candidate (((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) = ((7, 10), (7, 14), (3, 10), (8, 13)));\n   pragma Assert (Candidate (((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) = ((9, 12), (9, 16), (5, 12), (10, 15)));\n   pragma Assert (Candidate (((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) = ((11, 14), (11, 18), (7, 14), (12, 17)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_404_minimum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Minimum (A : Integer; B : Integer) return Integer;\n   -- Write a python function to find the minimum of two numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Minimum (A : Integer; B : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_404_minimum.py", "prompt_terminology": "verbatim", "tests": "\n   end Minimum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Integer renames Placeholder.Minimum;\n\nbegin\n   pragma Assert (Candidate (1, 2) = 1);\n   pragma Assert (Candidate (-5, -4) = -5);\n   pragma Assert (Candidate (0, 0) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_406_find_Parity", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Parity (X : Integer) return Boolean;\n   -- Write a python function to find whether the parity of a given number is odd.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Parity (X : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Parity;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (X : Integer) return Boolean renames Placeholder.Find_Parity;\n\nbegin\n   pragma Assert (Candidate (12) = False);\n   pragma Assert (Candidate (7) = True);\n   pragma Assert (Candidate (10) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_408_k_smallest_pairs", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function K_Smallest_Pairs (Nums1 : Integer_Array; Nums2 : Integer_Array; K : Integer) return Integer_Array_Array;\n   -- Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function K_Smallest_Pairs (Nums1 : Integer_Array; Nums2 : Integer_Array; K : Integer) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "verbatim", "tests": "\n   end K_Smallest_Pairs;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums1 : Integer_Array; Nums2 : Integer_Array; K : Integer) return Integer_Array_Array renames Placeholder.K_Smallest_Pairs;\n\nbegin\n   pragma Assert (Candidate ((1, 3, 7), (2, 4, 6), 2) = ((1, 2), (1, 4)));\n   pragma Assert (Candidate ((1, 3, 7), (2, 4, 6), 1) = (0 => (1, 2)));\n   pragma Assert (Candidate ((1, 3, 7), (2, 4, 6), 7) = ((1, 2), (1, 4), (3, 2), (1, 6), (3, 4), (3, 6), (7, 2)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_409_min_product_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Min_Product_Tuple (List1 : Integer_Integer_Tuple_Array) return Integer;\n   -- Write a function to find the minimum product from the pairs of tuples within a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Min_Product_Tuple (List1 : Integer_Integer_Tuple_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end Min_Product_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Integer_Tuple_Array) return Integer renames Placeholder.Min_Product_Tuple;\n\nbegin\n   pragma Assert (Candidate (((2, 7), (2, 6), (1, 8), (4, 9))) = 8);\n   pragma Assert (Candidate (((10, 20), (15, 2), (5, 10))) = 30);\n   pragma Assert (Candidate (((11, 44), (10, 15), (20, 5), (12, 9))) = 100);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_411_snake_to_camel", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Snake_To_Camel (Word : Unbounded_String) return Unbounded_String;\n   -- Write a function to convert the given snake case string to camel case string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Snake_To_Camel (Word : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "verbatim", "tests": "\n   end Snake_To_Camel;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Word : Unbounded_String) return Unbounded_String renames Placeholder.Snake_To_Camel;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"android_tv\")) = To_Unbounded_String (\"AndroidTv\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"google_pixel\")) = To_Unbounded_String (\"GooglePixel\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"apple_watch\")) = To_Unbounded_String (\"AppleWatch\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_412_remove_odd", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Remove_Odd (L : Integer_Array) return Integer_Array;\n   -- Write a python function to remove odd numbers from a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Odd (L : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Odd;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer_Array) return Integer_Array renames Placeholder.Remove_Odd;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = (0 => 2));\n   pragma Assert (Candidate ((2, 4, 6)) = (2, 4, 6));\n   pragma Assert (Candidate ((10, 20, 3)) = (10, 20));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_414_overlapping", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Overlapping (List1 : Integer_Array; List2 : Integer_Array) return Boolean;\n   -- Write a python function to check whether any value in a sequence exists in a sequence or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Overlapping (List1 : Integer_Array; List2 : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_414_overlapping.py", "prompt_terminology": "verbatim", "tests": "\n   end Overlapping;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array; List2 : Integer_Array) return Boolean renames Placeholder.Overlapping;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5), (6, 7, 8, 9)) = False);\n   pragma Assert (Candidate ((1, 2, 3), (4, 5, 6)) = False);\n   pragma Assert (Candidate ((1, 4, 5), (1, 4, 5)) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_415_max_Product", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Max_Product (Arr : Integer_Array) return Integer_Integer_Tuple;\n   -- Write a python function to find a pair with highest product from a given array of integers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Product (Arr : Integer_Array) return Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Product;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer_Integer_Tuple renames Placeholder.Max_Product;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 7, 0, 8, 4)) = (7, 8));\n   pragma Assert (Candidate ((0, -1, -2, -4, 5, 0, -6)) = (-4, -6));\n   pragma Assert (Candidate ((1, 2, 3)) = (2, 3));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_417_group_tuples", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   type Unbounded_String_Array_Array is array (Integer range <>) of Unbounded_String_Array;\n   function Group_Tuples (Input : Unbounded_String_Array_Array) return Unbounded_String_Array_Array;\n   -- Write a function to find common first element in given list of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Group_Tuples (Input : Unbounded_String_Array_Array) return Unbounded_String_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py", "prompt_terminology": "verbatim", "tests": "\n   end Group_Tuples;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Input : Unbounded_String_Array_Array) return Unbounded_String_Array_Array renames Placeholder.Group_Tuples;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"x\"), To_Unbounded_String (\"y\")), (To_Unbounded_String (\"x\"), To_Unbounded_String (\"z\")), (To_Unbounded_String (\"w\"), To_Unbounded_String (\"t\")))) = ((To_Unbounded_String (\"x\"), To_Unbounded_String (\"y\"), To_Unbounded_String (\"z\")), (To_Unbounded_String (\"w\"), To_Unbounded_String (\"t\"))));\n   pragma Assert (Candidate (((To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\")), (To_Unbounded_String (\"a\"), To_Unbounded_String (\"c\")), (To_Unbounded_String (\"d\"), To_Unbounded_String (\"e\")))) = ((To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\"), To_Unbounded_String (\"c\")), (To_Unbounded_String (\"d\"), To_Unbounded_String (\"e\"))));\n   pragma Assert (Candidate (((To_Unbounded_String (\"f\"), To_Unbounded_String (\"g\")), (To_Unbounded_String (\"f\"), To_Unbounded_String (\"g\")), (To_Unbounded_String (\"h\"), To_Unbounded_String (\"i\")))) = ((To_Unbounded_String (\"f\"), To_Unbounded_String (\"g\"), To_Unbounded_String (\"g\")), (To_Unbounded_String (\"h\"), To_Unbounded_String (\"i\"))));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_420_cube_Sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Cube_Sum (N : Integer) return Integer;\n   -- Write a python function to find the cube sum of first n even natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Cube_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_420_cube_Sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Cube_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Cube_Sum;\n\nbegin\n   pragma Assert (Candidate (2) = 72);\n   pragma Assert (Candidate (3) = 288);\n   pragma Assert (Candidate (4) = 800);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_421_concatenate_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Unbounded_String_Integer_Unbounded_String_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Unbounded_String_2 : Unbounded_String;\n     Integer_3 : Integer;\n     Unbounded_String_4 : Unbounded_String;\n   end record;\n\n   function Concatenate_Tuple (Test_Tup : Unbounded_String_Unbounded_String_Integer_Unbounded_String_Tuple) return Unbounded_String;\n   -- Write a function to concatenate each element of tuple by the delimiter.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Concatenate_Tuple (Test_Tup : Unbounded_String_Unbounded_String_Integer_Unbounded_String_Tuple) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end Concatenate_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup : Unbounded_String_Unbounded_String_Integer_Unbounded_String_Tuple) return Unbounded_String renames Placeholder.Concatenate_Tuple;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"ID\"), To_Unbounded_String (\"is\"), 4, To_Unbounded_String (\"UTS\"))) = To_Unbounded_String (\"ID-is-4-UTS\"));\n   pragma Assert (Candidate ((To_Unbounded_String (\"QWE\"), To_Unbounded_String (\"is\"), 4, To_Unbounded_String (\"RTY\"))) = To_Unbounded_String (\"QWE-is-4-RTY\"));\n   pragma Assert (Candidate ((To_Unbounded_String (\"ZEN\"), To_Unbounded_String (\"is\"), 4, To_Unbounded_String (\"OP\"))) = To_Unbounded_String (\"ZEN-is-4-OP\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Average_Of_Cube (N : Integer) return Float;\n   -- Write a python function to find the average of cubes of first n natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Average_Of_Cube (N : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Average_Of_Cube;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Float renames Placeholder.Find_Average_Of_Cube;\n\nbegin\n   pragma Assert (Candidate (2) = 4.5);\n   pragma Assert (Candidate (3) = 12);\n   pragma Assert (Candidate (1) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_424_extract_rear", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   type Unbounded_String_Unbounded_String_Unbounded_String_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Unbounded_String_2 : Unbounded_String;\n     Unbounded_String_3 : Unbounded_String;\n   end record;\n\n   function Extract_Rear (Test_Tuple : Unbounded_String_Unbounded_String_Unbounded_String_Tuple) return Unbounded_String_Array;\n   -- Write a function to extract only the rear index element of each string in the given tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Extract_Rear (Test_Tuple : Unbounded_String_Unbounded_String_Unbounded_String_Tuple) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "verbatim", "tests": "\n   end Extract_Rear;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tuple : Unbounded_String_Unbounded_String_Unbounded_String_Tuple) return Unbounded_String_Array renames Placeholder.Extract_Rear;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"Mers\"), To_Unbounded_String (\"for\"), To_Unbounded_String (\"Vers\"))) = (To_Unbounded_String (\"s\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"s\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Avenge\"), To_Unbounded_String (\"for\"), To_Unbounded_String (\"People\"))) = (To_Unbounded_String (\"e\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"e\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Gotta\"), To_Unbounded_String (\"get\"), To_Unbounded_String (\"go\"))) = (To_Unbounded_String (\"a\"), To_Unbounded_String (\"t\"), To_Unbounded_String (\"o\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_426_filter_oddnumbers", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Filter_Oddnumbers (Nums : Integer_Array) return Integer_Array;\n   -- Write a function to filter odd numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Filter_Oddnumbers (Nums : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "verbatim", "tests": "\n   end Filter_Oddnumbers;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer_Array renames Placeholder.Filter_Oddnumbers;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) = (1, 3, 5, 7, 9));\n   pragma Assert (Candidate ((10, 20, 45, 67, 84, 93)) = (45, 67, 93));\n   pragma Assert (Candidate ((5, 7, 9, 8, 6, 4, 3)) = (5, 7, 9, 3));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_427_change_date_format", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Change_Date_Format (Dt : Unbounded_String) return Unbounded_String;\n   -- Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Change_Date_Format (Dt : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "verbatim", "tests": "\n   end Change_Date_Format;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Dt : Unbounded_String) return Unbounded_String renames Placeholder.Change_Date_Format;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"2026-01-02\")) = To_Unbounded_String (\"02-01-2026\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"2020-11-13\")) = To_Unbounded_String (\"13-11-2020\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"2021-04-26\")) = To_Unbounded_String (\"26-04-2021\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_428_shell_sort", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Shell_Sort (My_List : Integer_Array) return Integer_Array;\n   -- Write a function to sort the given array by using shell sort.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Shell_Sort (My_List : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "verbatim", "tests": "\n   end Shell_Sort;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_List : Integer_Array) return Integer_Array renames Placeholder.Shell_Sort;\n\nbegin\n   pragma Assert (Candidate ((12, 23, 4, 5, 3, 2, 12, 81, 56, 95)) = (2, 3, 4, 5, 12, 12, 23, 56, 81, 95));\n   pragma Assert (Candidate ((24, 22, 39, 34, 87, 73, 68)) = (22, 24, 34, 39, 68, 73, 87));\n   pragma Assert (Candidate ((32, 30, 16, 96, 82, 83, 74)) = (16, 30, 32, 74, 82, 83, 96));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_429_and_tuples", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n   end record;\n\n   function And_Tuples (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function to extract the elementwise and tuples from the given two tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function And_Tuples (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_429_and_tuples.py", "prompt_terminology": "verbatim", "tests": "\n   end And_Tuples;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple renames Placeholder.And_Tuples;\n\nbegin\n   pragma Assert (Candidate ((10, 4, 6, 9), (5, 2, 3, 3)) = (0, 0, 2, 1));\n   pragma Assert (Candidate ((1, 2, 3, 4), (5, 6, 7, 8)) = (1, 2, 3, 0));\n   pragma Assert (Candidate ((8, 9, 11, 12), (7, 13, 14, 17)) = (0, 9, 10, 0));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_430_parabola_directrix", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Parabola_Directrix (A : Integer; B : Integer; C : Integer) return Integer;\n   -- Write a function to find the directrix of a parabola.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Parabola_Directrix (A : Integer; B : Integer; C : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "verbatim", "tests": "\n   end Parabola_Directrix;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer; C : Integer) return Integer renames Placeholder.Parabola_Directrix;\n\nbegin\n   pragma Assert (Candidate (5, 3, 2) = -198);\n   pragma Assert (Candidate (9, 8, 4) = -2336);\n   pragma Assert (Candidate (2, 4, 6) = -130);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_432_median_trapezium", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Median_Trapezium (Base1 : Integer; Base2 : Integer; Height : Integer) return Float;\n   -- Write a function to find the median length of a trapezium.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Median_Trapezium (Base1 : Integer; Base2 : Integer; Height : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "verbatim", "tests": "\n   end Median_Trapezium;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Base1 : Integer; Base2 : Integer; Height : Integer) return Float renames Placeholder.Median_Trapezium;\n\nbegin\n   pragma Assert (Candidate (15, 25, 35) = 20);\n   pragma Assert (Candidate (10, 20, 30) = 15);\n   pragma Assert (Candidate (6, 9, 4) = 7.5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_433_check_greater", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Check_Greater (Arr : Integer_Array; Number : Integer) return Boolean;\n   -- Write a function to check whether the entered number is greater than the elements of the given array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Greater (Arr : Integer_Array; Number : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Greater;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; Number : Integer) return Boolean renames Placeholder.Check_Greater;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5), 4) = False);\n   pragma Assert (Candidate ((2, 3, 4, 5, 6), 8) = True);\n   pragma Assert (Candidate ((9, 7, 4, 8, 6, 1), 11) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_434_text_match_one", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Match_One (Text : Unbounded_String) return Boolean;\n   -- Write a function that matches a string that has an a followed by one or more b's.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Match_One (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Match_One;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Match_One;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"ac\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"dc\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"abba\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_435_last_Digit", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Last_Digit (N : Integer) return Integer;\n   -- Write a python function to find the last digit of a given number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Last_Digit (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "verbatim", "tests": "\n   end Last_Digit;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Last_Digit;\n\nbegin\n   pragma Assert (Candidate (123) = 3);\n   pragma Assert (Candidate (25) = 5);\n   pragma Assert (Candidate (30) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_436_neg_nos", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Neg_Nos (List1 : Integer_Array) return Integer_Array;\n   -- Write a python function to return the negative numbers in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Neg_Nos (List1 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "verbatim", "tests": "\n   end Neg_Nos;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array) return Integer_Array renames Placeholder.Neg_Nos;\n\nbegin\n   pragma Assert (Candidate ((-1, 4, 5, -6)) = (-1, -6));\n   pragma Assert (Candidate ((-1, -2, 3, 4)) = (-1, -2));\n   pragma Assert (Candidate ((-7, -6, 8, 9)) = (-7, -6));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_437_remove_odd", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Odd (Str1 : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove odd characters in a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Odd (Str1 : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Odd;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String renames Placeholder.Remove_Odd;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python\")) = To_Unbounded_String (\"yhn\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"program\")) = To_Unbounded_String (\"rga\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"language\")) = To_Unbounded_String (\"agae\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_438_count_bidirectional", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Count_Bidirectional (Test_List : Integer_Integer_Tuple_Array) return Integer;\n   -- Write a function to count bidirectional tuple pairs.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Bidirectional (Test_List : Integer_Integer_Tuple_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Bidirectional;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Integer_Tuple_Array) return Integer renames Placeholder.Count_Bidirectional;\n\nbegin\n   pragma Assert (Candidate (((5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1))) = 3);\n   pragma Assert (Candidate (((5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1))) = 2);\n   pragma Assert (Candidate (((5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1))) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_439_multiple_to_single", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Multiple_To_Single (L : Integer_Array) return Integer;\n   -- Write a function to join a list of multiple integers into a single integer.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Multiple_To_Single (L : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_439_multiple_to_single.py", "prompt_terminology": "verbatim", "tests": "\n   end Multiple_To_Single;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer_Array) return Integer renames Placeholder.Multiple_To_Single;\n\nbegin\n   pragma Assert (Candidate ((11, 33, 50)) = 113350);\n   pragma Assert (Candidate ((-1, 2, 3, 4, 5, 6)) = -123456);\n   pragma Assert (Candidate ((10, 15, 20, 25)) = 10152025);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_440_find_adverb_position", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Unbounded_String_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Unbounded_String_3 : Unbounded_String;\n   end record;\n\n   function Find_Adverb_Position (Text : Unbounded_String) return Integer_Integer_Unbounded_String_Tuple;\n   -- Write a function to find the first adverb and their positions in a given sentence.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Adverb_Position (Text : Unbounded_String) return Integer_Integer_Unbounded_String_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Adverb_Position;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Integer_Integer_Unbounded_String_Tuple renames Placeholder.Find_Adverb_Position;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"clearly!! we can see the sky\")) = (0, 7, To_Unbounded_String (\"clearly\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"seriously!! there are many roses\")) = (0, 9, To_Unbounded_String (\"seriously\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"unfortunately!! sita is going to home\")) = (0, 13, To_Unbounded_String (\"unfortunately\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_441_surfacearea_cube", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Surfacearea_Cube (L : Integer) return Integer;\n   -- Write a function to find the surface area of a cube of a given size.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Surfacearea_Cube (L : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "verbatim", "tests": "\n   end Surfacearea_Cube;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer) return Integer renames Placeholder.Surfacearea_Cube;\n\nbegin\n   pragma Assert (Candidate (5) = 150);\n   pragma Assert (Candidate (3) = 54);\n   pragma Assert (Candidate (10) = 600);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_442_positive_count", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Positive_Count (Nums : Integer_Array) return Float;\n   -- Write a function to find the ration of positive numbers in an array of integers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Positive_Count (Nums : Integer_Array) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "verbatim", "tests": "\n   end Positive_Count;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Float renames Placeholder.Positive_Count;\n\nbegin\n   pragma Assert (Candidate ((0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8)) = 0.54);\n   pragma Assert (Candidate ((2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8)) = 0.69);\n   pragma Assert (Candidate ((2, 4, -6, -9, 11, -12, 14, -5, 17)) = 0.56);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_443_largest_neg", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Largest_Neg (List1 : Integer_Array) return Integer;\n   -- Write a python function to find the largest negative number from the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Largest_Neg (List1 : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "verbatim", "tests": "\n   end Largest_Neg;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array) return Integer renames Placeholder.Largest_Neg;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, -4, -6)) = -6);\n   pragma Assert (Candidate ((1, 2, 3, -8, -9)) = -9);\n   pragma Assert (Candidate ((1, 2, 3, 4, -1)) = -1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_444_trim_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Trim_Tuple (Test_List : Integer_Array_Array; K : Integer) return Integer_Array_Array;\n   -- Write a function to trim each list by k in the given lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Trim_Tuple (Test_List : Integer_Array_Array; K : Integer) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_444_trim_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end Trim_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Array_Array; K : Integer) return Integer_Array_Array renames Placeholder.Trim_Tuple;\n\nbegin\n   pragma Assert (Candidate (((5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)), 2) = ((0 => 2), (0 => 9), (0 => 2), (0 => 2)));\n   pragma Assert (Candidate (((5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)), 1) = ((3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)));\n   pragma Assert (Candidate (((7, 8, 4, 9), (11, 8, 12, 4), (4, 1, 7, 8), (3, 6, 9, 7)), 1) = ((8, 4), (8, 12), (1, 7), (6, 9)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_445_index_multiplication", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Index_Multiplication (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array;\n   -- Write a function to perform index wise multiplication of list elements in the given two lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Index_Multiplication (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "verbatim", "tests": "\n   end Index_Multiplication;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Array_Array; Test_Tup2 : Integer_Array_Array) return Integer_Array_Array renames Placeholder.Index_Multiplication;\n\nbegin\n   pragma Assert (Candidate (((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) = ((6, 21), (12, 45), (2, 9), (7, 30)));\n   pragma Assert (Candidate (((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) = ((14, 32), (20, 60), (6, 20), (16, 44)));\n   pragma Assert (Candidate (((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) = ((24, 45), (30, 77), (12, 33), (27, 60)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_447_cube_nums", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Cube_Nums (Nums : Integer_Array) return Integer_Array;\n   -- Write a function to find cubes of individual elements in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Cube_Nums (Nums : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "verbatim", "tests": "\n   end Cube_Nums;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer_Array renames Placeholder.Cube_Nums;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) = (1, 8, 27, 64, 125, 216, 343, 512, 729, 1000));\n   pragma Assert (Candidate ((10, 20, 30)) = (1000, 8000, 27000));\n   pragma Assert (Candidate ((12, 15)) = (1728, 3375));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_448_cal_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Cal_Sum (N : Integer) return Integer;\n   -- Write a function to calculate the sum of perrin numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Cal_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Cal_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Cal_Sum;\n\nbegin\n   pragma Assert (Candidate (9) = 49);\n   pragma Assert (Candidate (10) = 66);\n   pragma Assert (Candidate (11) = 88);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_450_extract_string", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Extract_String (Str : Unbounded_String_Array; L : Integer) return Unbounded_String_Array;\n   -- Write a function to extract specified size of strings from a given list of string values.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Extract_String (Str : Unbounded_String_Array; L : Integer) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "verbatim", "tests": "\n   end Extract_String;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String_Array; L : Integer) return Unbounded_String_Array renames Placeholder.Extract_String;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"Python\"), To_Unbounded_String (\"list\"), To_Unbounded_String (\"exercises\"), To_Unbounded_String (\"practice\"), To_Unbounded_String (\"solution\")), 8) = (To_Unbounded_String (\"practice\"), To_Unbounded_String (\"solution\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Python\"), To_Unbounded_String (\"list\"), To_Unbounded_String (\"exercises\"), To_Unbounded_String (\"practice\"), To_Unbounded_String (\"solution\")), 6) = (0 => To_Unbounded_String (\"Python\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Python\"), To_Unbounded_String (\"list\"), To_Unbounded_String (\"exercises\"), To_Unbounded_String (\"practice\"), To_Unbounded_String (\"solution\")), 9) = (0 => To_Unbounded_String (\"exercises\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_451_remove_whitespaces", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Whitespaces (Text1 : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove all whitespaces from the given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Whitespaces (Text1 : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Whitespaces;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text1 : Unbounded_String) return Unbounded_String renames Placeholder.Remove_Whitespaces;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\" Google    Flutter \")) = To_Unbounded_String (\"GoogleFlutter\"));\n   pragma Assert (Candidate (To_Unbounded_String (\" Google    Dart \")) = To_Unbounded_String (\"GoogleDart\"));\n   pragma Assert (Candidate (To_Unbounded_String (\" iOS    Swift \")) = To_Unbounded_String (\"iOSSwift\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_452_loss_amount", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Loss_Amount (Actual_Cost : Integer; Sale_Amount : Integer) return Integer;\n   -- Write a function that gives loss amount on a sale if the given amount has loss else return 0.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Loss_Amount (Actual_Cost : Integer; Sale_Amount : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "verbatim", "tests": "\n   end Loss_Amount;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Actual_Cost : Integer; Sale_Amount : Integer) return Integer renames Placeholder.Loss_Amount;\n\nbegin\n   pragma Assert (Candidate (1500, 1200) = 0);\n   pragma Assert (Candidate (100, 200) = 100);\n   pragma Assert (Candidate (2000, 5000) = 3000);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_453_sumofFactors", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sumof_Factors (N : Integer) return Integer;\n   -- Write a python function to find the sum of even factors of a number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sumof_Factors (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "verbatim", "tests": "\n   end Sumof_Factors;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Sumof_Factors;\n\nbegin\n   pragma Assert (Candidate (18) = 26);\n   pragma Assert (Candidate (30) = 48);\n   pragma Assert (Candidate (6) = 8);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_454_text_match_wordz", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Match_Wordz (Text : Unbounded_String) return Boolean;\n   -- Write a function that matches a word containing 'z'.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Match_Wordz (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Match_Wordz;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Match_Wordz;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"pythonz.\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"xyz.\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"  lang  .\")) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_455_check_monthnumb_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Check_Monthnumb_Number (Monthnum2 : Integer) return Boolean;\n   -- Write a function to check whether the given month number contains 31 days or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Monthnumb_Number (Monthnum2 : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Monthnumb_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Monthnum2 : Integer) return Boolean renames Placeholder.Check_Monthnumb_Number;\n\nbegin\n   pragma Assert (Candidate (5) = True);\n   pragma Assert (Candidate (2) = False);\n   pragma Assert (Candidate (6) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_456_reverse_string_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Reverse_String_List (Stringlist : Unbounded_String_Array) return Unbounded_String_Array;\n   -- Write a function to reverse each string in a given list of string values.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Reverse_String_List (Stringlist : Unbounded_String_Array) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_456_reverse_string_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Reverse_String_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Stringlist : Unbounded_String_Array) return Unbounded_String_Array renames Placeholder.Reverse_String_List;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"Red\"), To_Unbounded_String (\"Green\"), To_Unbounded_String (\"Blue\"), To_Unbounded_String (\"White\"), To_Unbounded_String (\"Black\"))) = (To_Unbounded_String (\"deR\"), To_Unbounded_String (\"neerG\"), To_Unbounded_String (\"eulB\"), To_Unbounded_String (\"etihW\"), To_Unbounded_String (\"kcalB\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"john\"), To_Unbounded_String (\"amal\"), To_Unbounded_String (\"joel\"), To_Unbounded_String (\"george\"))) = (To_Unbounded_String (\"nhoj\"), To_Unbounded_String (\"lama\"), To_Unbounded_String (\"leoj\"), To_Unbounded_String (\"egroeg\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"jack\"), To_Unbounded_String (\"john\"), To_Unbounded_String (\"mary\"))) = (To_Unbounded_String (\"kcaj\"), To_Unbounded_String (\"nhoj\"), To_Unbounded_String (\"yram\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_458_rectangle_area", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Rectangle_Area (L : Integer; B : Integer) return Integer;\n   -- Write a function to find the area of a rectangle.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Rectangle_Area (L : Integer; B : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "verbatim", "tests": "\n   end Rectangle_Area;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer; B : Integer) return Integer renames Placeholder.Rectangle_Area;\n\nbegin\n   pragma Assert (Candidate (10, 20) = 200);\n   pragma Assert (Candidate (10, 5) = 50);\n   pragma Assert (Candidate (4, 2) = 8);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_459_remove_uppercase", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Uppercase (Str1 : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove uppercase substrings from a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Uppercase (Str1 : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_459_remove_uppercase.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Uppercase;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String renames Placeholder.Remove_Uppercase;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"cAstyoUrFavoRitETVshoWs\")) = To_Unbounded_String (\"cstyoravoitshos\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"wAtchTheinTernEtrAdIo\")) = To_Unbounded_String (\"wtchheinerntrdo\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"VoicESeaRchAndreComMendaTionS\")) = To_Unbounded_String (\"oiceachndreomendaion\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_460_Extract", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Extract (Lst : Integer_Array_Array) return Integer_Array;\n   -- Write a python function to get the first element of each sublist.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Extract (Lst : Integer_Array_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "verbatim", "tests": "\n   end Extract;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Lst : Integer_Array_Array) return Integer_Array renames Placeholder.Extract;\n\nbegin\n   pragma Assert (Candidate (((1, 2), (3, 4, 5), (6, 7, 8, 9))) = (1, 3, 6));\n   pragma Assert (Candidate (((1, 2, 3), (4, 5))) = (1, 4));\n   pragma Assert (Candidate (((9, 8, 1), (1, 2))) = (9, 1));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_461_upper_ctr", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Upper_Ctr (Str : Unbounded_String) return Integer;\n   -- Write a python function to count the upper case characters in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Upper_Ctr (Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "verbatim", "tests": "\n   end Upper_Ctr;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String) return Integer renames Placeholder.Upper_Ctr;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"PYthon\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"BigData\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"program\")) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_463_max_subarray_product", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Subarray_Product (Arr : Integer_Array) return Integer;\n   -- Write a function to find the maximum product subarray of the given array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Subarray_Product (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Subarray_Product;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Max_Subarray_Product;\n\nbegin\n   pragma Assert (Candidate ((1, -2, -3, 0, 7, -8, -2)) = 112);\n   pragma Assert (Candidate ((6, -3, -10, 0, 2)) = 180);\n   pragma Assert (Candidate ((-2, -40, 0, -2, -3)) = 80);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_468_max_product", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Product (Arr : Integer_Array) return Integer;\n   -- Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Product (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Product;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Max_Product;\n\nbegin\n   pragma Assert (Candidate ((3, 100, 4, 5, 150, 6)) = 3000);\n   pragma Assert (Candidate ((4, 42, 55, 68, 80)) = 50265600);\n   pragma Assert (Candidate ((10, 22, 9, 33, 21, 50, 41, 60)) = 2460);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_470_add_pairwise", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n   end record;\n\n   type Integer_Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n     Integer_5 : Integer;\n   end record;\n\n   function Add_Pairwise (Test_Tup : Integer_Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function to find the pairwise addition of the neighboring elements of the given tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Add_Pairwise (Test_Tup : Integer_Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_470_add_pairwise.py", "prompt_terminology": "verbatim", "tests": "\n   end Add_Pairwise;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup : Integer_Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple renames Placeholder.Add_Pairwise;\n\nbegin\n   pragma Assert (Candidate ((1, 5, 7, 8, 10)) = (6, 12, 15, 18));\n   pragma Assert (Candidate ((2, 6, 8, 9, 11)) = (8, 14, 17, 20));\n   pragma Assert (Candidate ((3, 7, 9, 10, 12)) = (10, 16, 19, 22));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_471_find_remainder", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Remainder (Arr : Integer_Array; N : Integer) return Integer;\n   -- Write a python function to find the product of the array multiplication modulo n.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Remainder (Arr : Integer_Array; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Remainder;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; N : Integer) return Integer renames Placeholder.Find_Remainder;\n\nbegin\n   pragma Assert (Candidate ((100, 10, 5, 25, 35, 14), 11) = 9);\n   pragma Assert (Candidate ((1, 1, 1), 1) = 0);\n   pragma Assert (Candidate ((1, 2, 1), 2) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_472_check_Consecutive", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Check_Consecutive (L : Integer_Array) return Boolean;\n   -- Write a python function to check whether the given list contains consecutive numbers or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Consecutive (L : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Consecutive;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer_Array) return Boolean renames Placeholder.Check_Consecutive;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5)) = True);\n   pragma Assert (Candidate ((1, 2, 3, 5, 6)) = False);\n   pragma Assert (Candidate ((1, 2, 1)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_474_replace_char", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Replace_Char (Str1 : Unbounded_String; Ch : Unbounded_String; Newch : Unbounded_String) return Unbounded_String;\n   -- Write a function to replace characters in a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Replace_Char (Str1 : Unbounded_String; Ch : Unbounded_String; Newch : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "verbatim", "tests": "\n   end Replace_Char;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String; Ch : Unbounded_String; Newch : Unbounded_String) return Unbounded_String renames Placeholder.Replace_Char;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"polygon\"), To_Unbounded_String (\"y\"), To_Unbounded_String (\"l\")) = To_Unbounded_String (\"pollgon\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"character\"), To_Unbounded_String (\"c\"), To_Unbounded_String (\"a\")) = To_Unbounded_String (\"aharaater\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"python\"), To_Unbounded_String (\"l\"), To_Unbounded_String (\"a\")) = To_Unbounded_String (\"python\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_476_big_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Big_Sum (Nums : Integer_Array) return Integer;\n   -- Write a python function to find the sum of the largest and smallest value in a given array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Big_Sum (Nums : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Big_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer renames Placeholder.Big_Sum;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = 4);\n   pragma Assert (Candidate ((-1, 2, 3, 4)) = 3);\n   pragma Assert (Candidate ((2, 3, 6)) = 8);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_477_is_lower", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Lower (My_String : Unbounded_String) return Unbounded_String;\n   -- Write a python function to convert the given string to lower case.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Lower (My_String : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Lower;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Unbounded_String renames Placeholder.Is_Lower;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"InValid\")) = To_Unbounded_String (\"invalid\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"TruE\")) = To_Unbounded_String (\"true\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"SenTenCE\")) = To_Unbounded_String (\"sentence\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_478_remove_lowercase", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Lowercase (Str1 : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove lowercase substrings from a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Lowercase (Str1 : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Lowercase;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String renames Placeholder.Remove_Lowercase;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"PYTHon\")) = To_Unbounded_String (\"PYTH\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"FInD\")) = To_Unbounded_String (\"FID\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"STRinG\")) = To_Unbounded_String (\"STRG\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_479_first_Digit", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function First_Digit (N : Integer) return Integer;\n   -- Write a python function to find the first digit of a given number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function First_Digit (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "verbatim", "tests": "\n   end First_Digit;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.First_Digit;\n\nbegin\n   pragma Assert (Candidate (123) = 1);\n   pragma Assert (Candidate (456) = 4);\n   pragma Assert (Candidate (12) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_4_heap_queue_largest", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Heap_Queue_Largest (Nums : Integer_Array; N : Integer) return Integer_Array;\n   -- Write a function to find the n largest integers from a given list of numbers, returned in descending order.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Heap_Queue_Largest (Nums : Integer_Array; N : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "verbatim", "tests": "\n   end Heap_Queue_Largest;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array; N : Integer) return Integer_Array renames Placeholder.Heap_Queue_Largest;\n\nbegin\n   pragma Assert (Candidate ((25, 35, 22, 85, 14, 65, 75, 22, 58), 3) = (85, 75, 65));\n   pragma Assert (Candidate ((25, 35, 22, 85, 14, 65, 75, 22, 58), 2) = (85, 75));\n   pragma Assert (Candidate ((25, 35, 22, 85, 14, 65, 75, 22, 58), 5) = (85, 75, 65, 58, 35));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_554_Split", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Split (List : Integer_Array) return Integer_Array;\n   -- Write a python function which takes a list of integers and only returns the odd ones.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Split (List : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "verbatim", "tests": "\n   end Split;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List : Integer_Array) return Integer_Array renames Placeholder.Split;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6)) = (1, 3, 5));\n   pragma Assert (Candidate ((10, 11, 12, 13)) = (11, 13));\n   pragma Assert (Candidate ((7, 8, 9, 1)) = (7, 9, 1));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_555_difference", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Difference (N : Integer) return Integer;\n   -- Write a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Difference (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_555_difference.py", "prompt_terminology": "verbatim", "tests": "\n   end Difference;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Difference;\n\nbegin\n   pragma Assert (Candidate (3) = 30);\n   pragma Assert (Candidate (5) = 210);\n   pragma Assert (Candidate (2) = 6);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_556_find_Odd_Pair", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Odd_Pair (A : Integer_Array; N : Integer) return Integer;\n   -- Write a python function to count the number of pairs whose xor value is odd.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Odd_Pair (A : Integer_Array; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Odd_Pair;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; N : Integer) return Integer renames Placeholder.Find_Odd_Pair;\n\nbegin\n   pragma Assert (Candidate ((5, 4, 7, 2, 1), 5) = 6);\n   pragma Assert (Candidate ((7, 2, 8, 1, 0, 5, 11), 7) = 12);\n   pragma Assert (Candidate ((1, 2, 3), 3) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_557_toggle_string", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Toggle_String (My_String : Unbounded_String) return Unbounded_String;\n   -- Write a function to toggle the case of all characters in a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Toggle_String (My_String : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "verbatim", "tests": "\n   end Toggle_String;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Unbounded_String renames Placeholder.Toggle_String;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Python\")) = To_Unbounded_String (\"pYTHON\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Pangram\")) = To_Unbounded_String (\"pANGRAM\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"LIttLE\")) = To_Unbounded_String (\"liTTle\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_558_digit_distance_nums", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Digit_Distance_Nums (N1 : Integer; N2 : Integer) return Integer;\n   -- Write a python function to find the sum of the per-digit difference between two integers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Digit_Distance_Nums (N1 : Integer; N2 : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "verbatim", "tests": "\n   end Digit_Distance_Nums;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N1 : Integer; N2 : Integer) return Integer renames Placeholder.Digit_Distance_Nums;\n\nbegin\n   pragma Assert (Candidate (1, 2) = 1);\n   pragma Assert (Candidate (23, 56) = 6);\n   pragma Assert (Candidate (123, 256) = 7);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_559_max_sub_array_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Max_Sub_Array_Sum (A : Integer_Array; Size : Integer) return Integer;\n   -- Write a function to find the sum of the largest contiguous sublist in the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Sub_Array_Sum (A : Integer_Array; Size : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Sub_Array_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; Size : Integer) return Integer renames Placeholder.Max_Sub_Array_Sum;\n\nbegin\n   pragma Assert (Candidate ((-2, -3, 4, -1, -2, 1, 5, -3), 8) = 7);\n   pragma Assert (Candidate ((-3, -4, 5, -2, -3, 2, 6, -4), 8) = 8);\n   pragma Assert (Candidate ((-4, -5, 6, -3, -4, 3, 7, -5), 8) = 10);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_560_union_elements", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Union_Elements (Test_Tup1 : Integer_Array; Test_Tup2 : Integer_Array) return Integer_Array;\n   -- Write a function to find the union of the elements of two given lists and output them in sorted order.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Union_Elements (Test_Tup1 : Integer_Array; Test_Tup2 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "verbatim", "tests": "\n   end Union_Elements;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Array; Test_Tup2 : Integer_Array) return Integer_Array renames Placeholder.Union_Elements;\n\nbegin\n   pragma Assert (Candidate ((3, 4, 5, 6), (5, 7, 4, 10)) = (3, 4, 5, 6, 7, 10));\n   pragma Assert (Candidate ((1, 2, 3, 4), (3, 4, 5, 6)) = (1, 2, 3, 4, 5, 6));\n   pragma Assert (Candidate ((11, 12, 13, 14), (13, 15, 16, 17)) = (11, 12, 13, 14, 15, 16, 17));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_562_Find_Max_Length", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Find_Max_Length (Lst : Integer_Array_Array) return Integer;\n   -- Write a python function to find the length of the longest sublists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Max_Length (Lst : Integer_Array_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Max_Length;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Lst : Integer_Array_Array) return Integer renames Placeholder.Find_Max_Length;\n\nbegin\n   pragma Assert (Candidate (((0 => 1), (1, 4), (5, 6, 7, 8))) = 4);\n   pragma Assert (Candidate (((0, 1), (2, 2), (3, 2, 1))) = 3);\n   pragma Assert (Candidate (((0 => 7), (22, 23), (13, 14, 15), (10, 20, 30, 40, 50))) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_563_extract_values", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Extract_Values (Text : Unbounded_String) return Unbounded_String_Array;\n   -- Write a function to extract values between quotation marks from a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Extract_Values (Text : Unbounded_String) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "verbatim", "tests": "\n   end Extract_Values;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Unbounded_String_Array renames Placeholder.Extract_Values;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"\"\"Python\"\", \"\"PHP\"\", \"\"Java\"\"\")) = (To_Unbounded_String (\"Python\"), To_Unbounded_String (\"PHP\"), To_Unbounded_String (\"Java\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"\"\"python\"\",\"\"program\"\",\"\"language\"\"\")) = (To_Unbounded_String (\"python\"), To_Unbounded_String (\"program\"), To_Unbounded_String (\"language\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"\"\"red\"\",\"\"blue\"\",\"\"green\"\",\"\"yellow\"\"\")) = (To_Unbounded_String (\"red\"), To_Unbounded_String (\"blue\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"yellow\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_564_count_Pairs", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Count_Pairs (Arr : Integer_Array; N : Integer) return Integer;\n   -- Write a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Pairs (Arr : Integer_Array; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Pairs;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; N : Integer) return Integer renames Placeholder.Count_Pairs;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 1), 3) = 2);\n   pragma Assert (Candidate ((1, 1, 1, 1), 4) = 0);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5), 5) = 10);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_565_split", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Split (Word : Unbounded_String) return Unbounded_String_Array;\n   -- Write a python function to split a string into characters.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Split (Word : Unbounded_String) return Unbounded_String_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "verbatim", "tests": "\n   end Split;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Word : Unbounded_String) return Unbounded_String_Array renames Placeholder.Split;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python\")) = (To_Unbounded_String (\"p\"), To_Unbounded_String (\"y\"), To_Unbounded_String (\"t\"), To_Unbounded_String (\"h\"), To_Unbounded_String (\"o\"), To_Unbounded_String (\"n\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"Name\")) = (To_Unbounded_String (\"N\"), To_Unbounded_String (\"a\"), To_Unbounded_String (\"m\"), To_Unbounded_String (\"e\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"program\")) = (To_Unbounded_String (\"p\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"o\"), To_Unbounded_String (\"g\"), To_Unbounded_String (\"r\"), To_Unbounded_String (\"a\"), To_Unbounded_String (\"m\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_566_sum_digits", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sum_Digits (N : Integer) return Integer;\n   -- Write a function to get the sum of the digits of a non-negative integer.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Digits (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Digits;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Sum_Digits;\n\nbegin\n   pragma Assert (Candidate (345) = 12);\n   pragma Assert (Candidate (12) = 3);\n   pragma Assert (Candidate (97) = 16);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_567_issort_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Issort_List (List1 : Integer_Array) return Boolean;\n   -- Write a function to check whether a specified list is sorted or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Issort_List (List1 : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Issort_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array) return Boolean renames Placeholder.Issort_List;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 4, 6, 8, 10, 12, 14, 16, 17)) = True);\n   pragma Assert (Candidate ((1, 2, 4, 6, 8, 10, 12, 14, 20, 17)) = False);\n   pragma Assert (Candidate ((1, 2, 4, 6, 8, 10, 15, 14, 20)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_569_sort_sublists", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   type Unbounded_String_Array_Array is array (Integer range <>) of Unbounded_String_Array;\n   function Sort_Sublists (List1 : Unbounded_String_Array_Array) return Unbounded_String_Array_Array;\n   -- Write a function to sort each sublist of strings in a given list of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sort_Sublists (List1 : Unbounded_String_Array_Array) return Unbounded_String_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "verbatim", "tests": "\n   end Sort_Sublists;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Unbounded_String_Array_Array) return Unbounded_String_Array_Array renames Placeholder.Sort_Sublists;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\")), (To_Unbounded_String (\"white\"), To_Unbounded_String (\"black\"), To_Unbounded_String (\"orange\")))) = ((To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\")), (To_Unbounded_String (\"black\"), To_Unbounded_String (\"orange\"), To_Unbounded_String (\"white\"))));\n   pragma Assert (Candidate (((To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (0 => To_Unbounded_String (\"black\")), (To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (0 => To_Unbounded_String (\"white\")))) = ((To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (0 => To_Unbounded_String (\"black\")), (To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), (0 => To_Unbounded_String (\"white\"))));\n   pragma Assert (Candidate (((To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\")), (To_Unbounded_String (\"d\"), To_Unbounded_String (\"c\")), (To_Unbounded_String (\"g\"), To_Unbounded_String (\"h\")), (To_Unbounded_String (\"f\"), To_Unbounded_String (\"e\")))) = ((To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\")), (To_Unbounded_String (\"c\"), To_Unbounded_String (\"d\")), (To_Unbounded_String (\"g\"), To_Unbounded_String (\"h\")), (To_Unbounded_String (\"e\"), To_Unbounded_String (\"f\"))));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_56_checks", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Checks (N : Integer) return Boolean;\n   -- Write a python function to check if a given number is one less than twice its reverse.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Checks (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "verbatim", "tests": "\n   end Checks;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Checks;\n\nbegin\n   pragma Assert (Candidate (70) = False);\n   pragma Assert (Candidate (23) = False);\n   pragma Assert (Candidate (73) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_572_two_unique_nums", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Two_Unique_Nums (Nums : Integer_Array) return Integer_Array;\n   -- Write a python function to remove duplicate numbers from a given number of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Two_Unique_Nums (Nums : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "verbatim", "tests": "\n   end Two_Unique_Nums;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer_Array renames Placeholder.Two_Unique_Nums;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 2, 3, 4, 5)) = (1, 4, 5));\n   pragma Assert (Candidate ((1, 2, 3, 2, 4, 5)) = (1, 3, 4, 5));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5)) = (1, 2, 3, 4, 5));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_573_unique_product", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Unique_Product (List_Data : Integer_Array) return Integer;\n   -- Write a python function to calculate the product of the unique numbers in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Unique_Product (List_Data : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "verbatim", "tests": "\n   end Unique_Product;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List_Data : Integer_Array) return Integer renames Placeholder.Unique_Product;\n\nbegin\n   pragma Assert (Candidate ((10, 20, 30, 40, 20, 50, 60, 40)) = 720000000);\n   pragma Assert (Candidate ((1, 2, 3, 1)) = 6);\n   pragma Assert (Candidate ((7, 8, 9, 0, 1, 1)) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_574_surfacearea_cylinder", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Surfacearea_Cylinder (R : Integer; H : Integer) return Float;\n   -- Write a function to find the surface area of a cylinder.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Surfacearea_Cylinder (R : Integer; H : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "verbatim", "tests": "\n   end Surfacearea_Cylinder;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (R : Integer; H : Integer) return Float renames Placeholder.Surfacearea_Cylinder;\n\nbegin\n   pragma Assert (Candidate (10, 5) = 942.45);\n   pragma Assert (Candidate (4, 5) = 226.18800000000002);\n   pragma Assert (Candidate (4, 10) = 351.848);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_576_is_Sub_Array", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Is_Sub_Array (A : Integer_Array; B : Integer_Array) return Boolean;\n   -- Write a python function to check whether a list is sublist of another or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Sub_Array (A : Integer_Array; B : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Sub_Array;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; B : Integer_Array) return Boolean renames Placeholder.Is_Sub_Array;\n\nbegin\n   pragma Assert (Candidate ((1, 4, 3, 5), (1, 2)) = False);\n   pragma Assert (Candidate ((1, 2, 1), (1, 2, 1)) = True);\n   pragma Assert (Candidate ((1, 0, 2, 2), (2, 2, 0)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_577_last_Digit_Factorial", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Last_Digit_Factorial (N : Integer) return Integer;\n   -- Write a python function to find the last digit in factorial of a given number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Last_Digit_Factorial (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_577_last_Digit_Factorial.py", "prompt_terminology": "verbatim", "tests": "\n   end Last_Digit_Factorial;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Last_Digit_Factorial;\n\nbegin\n   pragma Assert (Candidate (4) = 4);\n   pragma Assert (Candidate (21) = 0);\n   pragma Assert (Candidate (30) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_578_interleave_lists", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Interleave_Lists (List1 : Integer_Array; List2 : Integer_Array; List3 : Integer_Array) return Integer_Array;\n   -- Write a function to interleave 3 lists of the same length into a single flat list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Interleave_Lists (List1 : Integer_Array; List2 : Integer_Array; List3 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "verbatim", "tests": "\n   end Interleave_Lists;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array; List2 : Integer_Array; List3 : Integer_Array) return Integer_Array renames Placeholder.Interleave_Lists;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7), (10, 20, 30, 40, 50, 60, 70), (100, 200, 300, 400, 500, 600, 700)) = (1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700));\n   pragma Assert (Candidate ((10, 20), (15, 2), (5, 10)) = (10, 15, 5, 20, 2, 10));\n   pragma Assert (Candidate ((11, 44), (10, 15), (20, 5)) = (11, 10, 20, 44, 15, 5));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_579_find_dissimilar", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n   end record;\n\n   function Find_Dissimilar (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function to find the dissimilar elements in the given two tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Dissimilar (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Dissimilar;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple renames Placeholder.Find_Dissimilar;\n\nbegin\n   pragma Assert (Candidate ((3, 4, 5, 6), (5, 7, 4, 10)) = (3, 6, 7, 10));\n   pragma Assert (Candidate ((1, 2, 3, 4), (7, 2, 3, 9)) = (1, 4, 7, 9));\n   pragma Assert (Candidate ((21, 11, 25, 26), (26, 34, 21, 36)) = (34, 36, 11, 25));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_57_find_Max_Num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Max_Num (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the largest number that can be formed with the given list of digits.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Max_Num (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Max_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Find_Max_Num;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = 321);\n   pragma Assert (Candidate ((4, 5, 6, 1)) = 6541);\n   pragma Assert (Candidate ((1, 2, 3, 9)) = 9321);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_581_surface_Area", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Surface_Area (B : Integer; S : Integer) return Integer;\n   -- Write a python function to find the surface area of a square pyramid with a given base edge and height.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Surface_Area (B : Integer; S : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_581_surface_Area.py", "prompt_terminology": "verbatim", "tests": "\n   end Surface_Area;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (B : Integer; S : Integer) return Integer renames Placeholder.Surface_Area;\n\nbegin\n   pragma Assert (Candidate (3, 4) = 33);\n   pragma Assert (Candidate (4, 5) = 56);\n   pragma Assert (Candidate (1, 2) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_583_catalan_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Catalan_Number (Num : Integer) return Integer;\n   -- Write a function which returns nth catalan number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Catalan_Number (Num : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Catalan_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num : Integer) return Integer renames Placeholder.Catalan_Number;\n\nbegin\n   pragma Assert (Candidate (10) = 16796);\n   pragma Assert (Candidate (9) = 4862);\n   pragma Assert (Candidate (7) = 429);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_584_find_adverbs", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Adverbs (Text : Unbounded_String) return Unbounded_String;\n   -- Write a function to find the first adverb ending with ly and its positions in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Adverbs (Text : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Adverbs;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Unbounded_String renames Placeholder.Find_Adverbs;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Clearly, he has no excuse for such behavior.\")) = To_Unbounded_String (\"0-7: Clearly\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Please handle the situation carefuly\")) = To_Unbounded_String (\"28-36: carefuly\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Complete the task quickly\")) = To_Unbounded_String (\"18-25: quickly\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_586_split_Arr", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Split_Arr (L : Integer_Array; N : Integer) return Integer_Array;\n   -- Write a python function to split a list at the nth eelment and add the first part to the end.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Split_Arr (L : Integer_Array; N : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py", "prompt_terminology": "verbatim", "tests": "\n   end Split_Arr;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer_Array; N : Integer) return Integer_Array renames Placeholder.Split_Arr;\n\nbegin\n   pragma Assert (Candidate ((12, 10, 5, 6, 52, 36), 2) = (5, 6, 52, 36, 12, 10));\n   pragma Assert (Candidate ((1, 2, 3, 4), 1) = (2, 3, 4, 1));\n   pragma Assert (Candidate ((0, 1, 2, 3, 4, 5, 6, 7), 3) = (3, 4, 5, 6, 7, 0, 1, 2));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_588_big_diff", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Big_Diff (Nums : Integer_Array) return Integer;\n   -- Write a python function to find the difference between largest and smallest value in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Big_Diff (Nums : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "verbatim", "tests": "\n   end Big_Diff;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer renames Placeholder.Big_Diff;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4)) = 3);\n   pragma Assert (Candidate ((4, 5, 12)) = 8);\n   pragma Assert (Candidate ((9, 2, 3)) = 7);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_589_perfect_squares", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Perfect_Squares (A : Integer; B : Integer) return Integer_Array;\n   -- Write a function to find perfect squares between two given numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Perfect_Squares (A : Integer; B : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "verbatim", "tests": "\n   end Perfect_Squares;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Integer_Array renames Placeholder.Perfect_Squares;\n\nbegin\n   pragma Assert (Candidate (1, 30) = (1, 4, 9, 16, 25));\n   pragma Assert (Candidate (50, 100) = (64, 81, 100));\n   pragma Assert (Candidate (100, 200) = (100, 121, 144, 169, 196));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_58_opposite_Signs", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Opposite_Signs (X : Integer; Y : Integer) return Boolean;\n   -- Write a python function to check whether the given two integers have opposite sign or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Opposite_Signs (X : Integer; Y : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "verbatim", "tests": "\n   end Opposite_Signs;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (X : Integer; Y : Integer) return Boolean renames Placeholder.Opposite_Signs;\n\nbegin\n   pragma Assert (Candidate (1, -2) = True);\n   pragma Assert (Candidate (3, 2) = False);\n   pragma Assert (Candidate (-10, -10) = False);\n   pragma Assert (Candidate (-2, 2) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_591_swap_List", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Swap_List (Newlist : Integer_Array) return Integer_Array;\n   -- Write a python function to interchange the first and last elements in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Swap_List (Newlist : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "verbatim", "tests": "\n   end Swap_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Newlist : Integer_Array) return Integer_Array renames Placeholder.Swap_List;\n\nbegin\n   pragma Assert (Candidate ((12, 35, 9, 56, 24)) = (24, 35, 9, 56, 12));\n   pragma Assert (Candidate ((1, 2, 3)) = (3, 2, 1));\n   pragma Assert (Candidate ((4, 5, 6)) = (6, 5, 4));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_592_sum_Of_product", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sum_Of_Product (N : Integer) return Integer;\n   -- Write a python function to find the sum of the product of consecutive binomial co-efficients.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Of_Product (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Of_Product;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Sum_Of_Product;\n\nbegin\n   pragma Assert (Candidate (3) = 15);\n   pragma Assert (Candidate (4) = 56);\n   pragma Assert (Candidate (1) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_593_removezero_ip", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Removezero_Ip (Ip : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove leading zeroes from an ip address.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Removezero_Ip (Ip : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_593_removezero_ip.py", "prompt_terminology": "verbatim", "tests": "\n   end Removezero_Ip;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Ip : Unbounded_String) return Unbounded_String renames Placeholder.Removezero_Ip;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"216.08.094.196\")) = To_Unbounded_String (\"216.8.94.196\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"12.01.024\")) = To_Unbounded_String (\"12.1.24\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"216.08.094.0196\")) = To_Unbounded_String (\"216.8.94.196\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_594_diff_even_odd", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Diff_Even_Odd (List1 : Integer_Array) return Integer;\n   -- Write a function to find the difference of the first even and first odd number of a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Diff_Even_Odd (List1 : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "verbatim", "tests": "\n   end Diff_Even_Odd;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array) return Integer renames Placeholder.Diff_Even_Odd;\n\nbegin\n   pragma Assert (Candidate ((1, 3, 5, 7, 4, 1, 6, 8)) = 3);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) = 1);\n   pragma Assert (Candidate ((1, 5, 7, 9, 10)) = 9);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_597_find_kth", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Kth (Arr1 : Integer_Array; Arr2 : Integer_Array; K : Integer) return Integer;\n   -- Write a function to find kth element from the given two sorted arrays.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Kth (Arr1 : Integer_Array; Arr2 : Integer_Array; K : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Kth;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr1 : Integer_Array; Arr2 : Integer_Array; K : Integer) return Integer renames Placeholder.Find_Kth;\n\nbegin\n   pragma Assert (Candidate ((2, 3, 6, 7, 9), (1, 4, 8, 10), 5) = 6);\n   pragma Assert (Candidate ((100, 112, 256, 349, 770), (72, 86, 113, 119, 265, 445, 892), 7) = 256);\n   pragma Assert (Candidate ((3, 4, 7, 8, 10), (2, 5, 9, 11), 6) = 8);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_598_armstrong_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Armstrong_Number (Number : Integer) return Boolean;\n   -- Write a function to check whether the given number is armstrong or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Armstrong_Number (Number : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Armstrong_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Number : Integer) return Boolean renames Placeholder.Armstrong_Number;\n\nbegin\n   pragma Assert (Candidate (153) = True);\n   pragma Assert (Candidate (259) = False);\n   pragma Assert (Candidate (4458) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_599_sum_average", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Float_Tuple is record\n     Integer_1 : Integer;\n     Float_2 : Float;\n   end record;\n\n   function Sum_Average (Number : Integer) return Integer_Float_Tuple;\n   -- Write a function to find sum and average of first n natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Average (Number : Integer) return Integer_Float_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_599_sum_average.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Average;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Number : Integer) return Integer_Float_Tuple renames Placeholder.Sum_Average;\n\nbegin\n   pragma Assert (Candidate (10) = (55, 5.5));\n   pragma Assert (Candidate (15) = (120, 8.0));\n   pragma Assert (Candidate (20) = (210, 10.5));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_59_is_octagonal", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Octagonal (N : Integer) return Integer;\n   -- Write a function to find the nth octagonal number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Octagonal (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Octagonal;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Is_Octagonal;\n\nbegin\n   pragma Assert (Candidate (5) = 65);\n   pragma Assert (Candidate (10) = 280);\n   pragma Assert (Candidate (15) = 645);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_600_is_Even", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Even (N : Integer) return Boolean;\n   -- Write a python function to check whether the given number is even or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Even (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Even;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Is_Even;\n\nbegin\n   pragma Assert (Candidate (1) = False);\n   pragma Assert (Candidate (2) = True);\n   pragma Assert (Candidate (3) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_602_first_repeated_char", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Option (Valid : Boolean := False) is record\n   case Valid is\n      when True =>\n         Value : Unbounded_String;\n      when False =>\n         null;\n   end case;\nend record;\n   function First_Repeated_Char (Str1 : Unbounded_String) return Unbounded_String_Option;\n   -- Write a python function to find the first repeated character in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function First_Repeated_Char (Str1 : Unbounded_String) return Unbounded_String_Option", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "verbatim", "tests": "\n   end First_Repeated_Char;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String_Option renames Placeholder.First_Repeated_Char;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"abcabc\")) = (Valid => True, Value => To_Unbounded_String (\"a\")));\n   pragma Assert (Candidate (To_Unbounded_String (\"abc\")) = (Valid => False));\n   pragma Assert (Candidate (To_Unbounded_String (\"123123\")) = (Valid => True, Value => To_Unbounded_String (\"1\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_603_get_ludic", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Get_Ludic (N : Integer) return Integer_Array;\n   -- Write a function to get all lucid numbers smaller than or equal to a given integer.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Ludic (N : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Ludic;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer_Array renames Placeholder.Get_Ludic;\n\nbegin\n   pragma Assert (Candidate (10) = (1, 2, 3, 5, 7));\n   pragma Assert (Candidate (25) = (1, 2, 3, 5, 7, 11, 13, 17, 23, 25));\n   pragma Assert (Candidate (45) = (1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_604_reverse_words", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Reverse_Words (S : Unbounded_String) return Unbounded_String;\n   -- Write a function to reverse words seperated by spaces in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Reverse_Words (S : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "verbatim", "tests": "\n   end Reverse_Words;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String) return Unbounded_String renames Placeholder.Reverse_Words;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python program\")) = To_Unbounded_String (\"program python\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"java language\")) = To_Unbounded_String (\"language java\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"indian man\")) = To_Unbounded_String (\"man indian\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_605_prime_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Prime_Num (Num : Integer) return Boolean;\n   -- Write a function to check if the given integer is a prime number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Prime_Num (Num : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Prime_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num : Integer) return Boolean renames Placeholder.Prime_Num;\n\nbegin\n   pragma Assert (Candidate (13) = True);\n   pragma Assert (Candidate (7) = True);\n   pragma Assert (Candidate (-1010) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_606_radian_degree", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Radian_Degree (Degree : Integer) return Float;\n   -- Write a function to convert degrees to radians.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Radian_Degree (Degree : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "verbatim", "tests": "\n   end Radian_Degree;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Degree : Integer) return Float renames Placeholder.Radian_Degree;\n\nbegin\n   pragma Assert (Candidate (90) = 1.5707963267948966);\n   pragma Assert (Candidate (60) = 1.0471975511965976);\n   pragma Assert (Candidate (120) = 2.0943951023931953);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_607_find_literals", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Integer_Integer_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Find_Literals (Text : Unbounded_String; Pattern : Unbounded_String) return Unbounded_String_Integer_Integer_Tuple;\n   -- Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Literals (Text : Unbounded_String; Pattern : Unbounded_String) return Unbounded_String_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Literals;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String; Pattern : Unbounded_String) return Unbounded_String_Integer_Integer_Tuple renames Placeholder.Find_Literals;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"The quick brown fox jumps over the lazy dog.\"), To_Unbounded_String (\"fox\")) = (To_Unbounded_String (\"fox\"), 16, 19));\n   pragma Assert (Candidate (To_Unbounded_String (\"Its been a very crazy procedure right\"), To_Unbounded_String (\"crazy\")) = (To_Unbounded_String (\"crazy\"), 16, 21));\n   pragma Assert (Candidate (To_Unbounded_String (\"Hardest choices required strongest will\"), To_Unbounded_String (\"will\")) = (To_Unbounded_String (\"will\"), 35, 39));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_608_bell_Number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Bell_Number (N : Integer) return Integer;\n   -- Write a python function to find nth bell number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Bell_Number (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "verbatim", "tests": "\n   end Bell_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Bell_Number;\n\nbegin\n   pragma Assert (Candidate (2) = 2);\n   pragma Assert (Candidate (3) = 5);\n   pragma Assert (Candidate (4) = 15);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_610_remove_kth_element", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Remove_Kth_Element (List1 : Integer_Array; L : Integer) return Integer_Array;\n   -- Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Kth_Element (List1 : Integer_Array; L : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_610_remove_kth_element.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Kth_Element;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array; L : Integer) return Integer_Array renames Placeholder.Remove_Kth_Element;\n\nbegin\n   pragma Assert (Candidate ((1, 1, 2, 3, 4, 4, 5, 1), 3) = (1, 1, 3, 4, 4, 5, 1));\n   pragma Assert (Candidate ((0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4), 4) = (0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4));\n   pragma Assert (Candidate ((10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10), 5) = (10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_611_max_of_nth", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Max_Of_Nth (Test_List : Integer_Array_Array; N : Integer) return Integer;\n   -- Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Of_Nth (Test_List : Integer_Array_Array; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Of_Nth;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Array_Array; N : Integer) return Integer renames Placeholder.Max_Of_Nth;\n\nbegin\n   pragma Assert (Candidate (((5, 6, 7), (1, 3, 5), (8, 9, 19)), 2) = 19);\n   pragma Assert (Candidate (((6, 7, 8), (2, 4, 6), (9, 10, 20)), 1) = 10);\n   pragma Assert (Candidate (((7, 8, 9), (3, 5, 7), (10, 11, 21)), 1) = 11);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_614_cummulative_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Cummulative_Sum (Test_List : Integer_Array_Array) return Integer;\n   -- Write a function to find the cumulative sum of all the values that are present in the given list of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Cummulative_Sum (Test_List : Integer_Array_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Cummulative_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Array_Array) return Integer renames Placeholder.Cummulative_Sum;\n\nbegin\n   pragma Assert (Candidate (((1, 3), (5, 6, 7), (2, 6))) = 30);\n   pragma Assert (Candidate (((2, 4), (6, 7, 8), (3, 7))) = 37);\n   pragma Assert (Candidate (((3, 5), (7, 8, 9), (4, 8))) = 44);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_615_average_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Float_Array is array (Integer range <>) of Float;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Average_Tuple (Nums : Integer_Array_Array) return Float_Array;\n   -- Write a function which takes a lists of lists and returns the average value for each sublist as a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Average_Tuple (Nums : Integer_Array_Array) return Float_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end Average_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array_Array) return Float_Array renames Placeholder.Average_Tuple;\n\nbegin\n   pragma Assert (Candidate (((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4))) = (30.5, 34.25, 27.0, 23.25));\n   pragma Assert (Candidate (((1, 1, -5), (30, -15, 56), (81, -60, -39), (-10, 2, 3))) = (25.5, -18.0, 3.75));\n   pragma Assert (Candidate (((100, 100, 100, 120), (300, 450, 560, 450), (810, 800, 390, 320), (10, 20, 30, 40))) = (305.0, 342.5, 270.0, 232.5));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_616_tuple_modulo", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n     Integer_4 : Integer;\n   end record;\n\n   function Tuple_Modulo (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple;\n   -- Write a function which takes two tuples of the same length and performs the element wise modulo.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Tuple_Modulo (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_616_tuple_modulo.py", "prompt_terminology": "verbatim", "tests": "\n   end Tuple_Modulo;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Integer_Tuple) return Integer_Integer_Integer_Integer_Tuple renames Placeholder.Tuple_Modulo;\n\nbegin\n   pragma Assert (Candidate ((10, 4, 5, 6), (5, 6, 7, 5)) = (0, 4, 5, 1));\n   pragma Assert (Candidate ((11, 5, 6, 7), (6, 7, 8, 6)) = (5, 5, 6, 1));\n   pragma Assert (Candidate ((12, 6, 7, 8), (7, 8, 9, 7)) = (5, 6, 7, 1));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_617_min_Jumps", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Min_Jumps (Steps : Integer_Integer_Tuple; D : Integer) return Float;\n   -- Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Min_Jumps (Steps : Integer_Integer_Tuple; D : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py", "prompt_terminology": "verbatim", "tests": "\n   end Min_Jumps;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Steps : Integer_Integer_Tuple; D : Integer) return Float renames Placeholder.Min_Jumps;\n\nbegin\n   pragma Assert (Candidate ((3, 4), 11) = 3.5);\n   pragma Assert (Candidate ((3, 4), 0) = 0);\n   pragma Assert (Candidate ((11, 14), 11) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_618_div_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Float_Array is array (Integer range <>) of Float;\n   function Div_List (Nums1 : Integer_Array; Nums2 : Integer_Array) return Float_Array;\n   -- Write a function to divide two lists element wise.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Div_List (Nums1 : Integer_Array; Nums2 : Integer_Array) return Float_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Div_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums1 : Integer_Array; Nums2 : Integer_Array) return Float_Array renames Placeholder.Div_List;\n\nbegin\n   pragma Assert (Candidate ((4, 5, 6), (1, 2, 3)) = (4.0, 2.5, 2.0));\n   pragma Assert (Candidate ((3, 2), (1, 4)) = (3.0, 0.5));\n   pragma Assert (Candidate ((90, 120), (50, 70)) = (1.8, 1.7142857142857142));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_619_move_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Move_Num (Test_Str : Unbounded_String) return Unbounded_String;\n   -- Write a function to move all the numbers to the end of the given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Move_Num (Test_Str : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Move_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Str : Unbounded_String) return Unbounded_String renames Placeholder.Move_Num;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"I1love143you55three3000thousand\")) = To_Unbounded_String (\"Iloveyouthreethousand1143553000\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Avengers124Assemble\")) = To_Unbounded_String (\"AvengersAssemble124\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Its11our12path13to14see15things16do17things\")) = To_Unbounded_String (\"Itsourpathtoseethingsdothings11121314151617\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_61_count_Substrings", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Substrings (S : Unbounded_String) return Integer;\n   -- Write a python function to count the number of substrings with the sum of digits equal to their length.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Substrings (S : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_61_count_Substrings.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Substrings;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String) return Integer renames Placeholder.Count_Substrings;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"112112\")) = 6);\n   pragma Assert (Candidate (To_Unbounded_String (\"111\")) = 6);\n   pragma Assert (Candidate (To_Unbounded_String (\"1101112\")) = 12);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_622_get_median", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Get_Median (Arr1 : Integer_Array; Arr2 : Integer_Array; N : Integer) return Float;\n   -- Write a function to find the median of two sorted lists of same size.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Median (Arr1 : Integer_Array; Arr2 : Integer_Array; N : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Median;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr1 : Integer_Array; Arr2 : Integer_Array; N : Integer) return Float renames Placeholder.Get_Median;\n\nbegin\n   pragma Assert (Candidate ((1, 12, 15, 26, 38), (2, 13, 17, 30, 45), 5) = 16.0);\n   pragma Assert (Candidate ((2, 4, 8, 9), (7, 13, 19, 28), 4) = 8.5);\n   pragma Assert (Candidate ((3, 6, 14, 23, 36, 42), (2, 18, 27, 39, 49, 55), 6) = 25.0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_623_nth_nums", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Nth_Nums (Nums : Integer_Array; N : Integer) return Integer_Array;\n   -- Write a function to compute the n-th power of each number in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Nth_Nums (Nums : Integer_Array; N : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "verbatim", "tests": "\n   end Nth_Nums;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array; N : Integer) return Integer_Array renames Placeholder.Nth_Nums;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 2) = (1, 4, 9, 16, 25, 36, 49, 64, 81, 100));\n   pragma Assert (Candidate ((10, 20, 30), 3) = (1000, 8000, 27000));\n   pragma Assert (Candidate ((12, 15), 5) = (248832, 759375));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_624_is_upper", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Upper (My_String : Unbounded_String) return Unbounded_String;\n   -- Write a python function to convert a given string to uppercase.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Upper (My_String : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Upper;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Unbounded_String renames Placeholder.Is_Upper;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"person\")) = To_Unbounded_String (\"PERSON\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"final\")) = To_Unbounded_String (\"FINAL\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Valid\")) = To_Unbounded_String (\"VALID\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_625_swap_List", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Swap_List (Newlist : Integer_Array) return Integer_Array;\n   -- Write a python function to interchange the first and last element in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Swap_List (Newlist : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "verbatim", "tests": "\n   end Swap_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Newlist : Integer_Array) return Integer_Array renames Placeholder.Swap_List;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = (3, 2, 1));\n   pragma Assert (Candidate ((1, 2, 3, 4, 4)) = (4, 2, 3, 4, 1));\n   pragma Assert (Candidate ((4, 5, 6)) = (6, 5, 4));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_626_triangle_area", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Option (Valid : Boolean := False) is record\n   case Valid is\n      when True =>\n         Value : Integer;\n      when False =>\n         null;\n   end case;\nend record;\n   function Triangle_Area (R : Integer) return Integer_Option;\n   -- Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Triangle_Area (R : Integer) return Integer_Option", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "verbatim", "tests": "\n   end Triangle_Area;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (R : Integer) return Integer_Option renames Placeholder.Triangle_Area;\n\nbegin\n   pragma Assert (Candidate (-1) = (Valid => False));\n   pragma Assert (Candidate (0) = (Valid => True, Value => 0));\n   pragma Assert (Candidate (2) = (Valid => True, Value => 4));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_627_find_First_Missing", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_First_Missing (My_Array : Integer_Array) return Integer;\n   -- Write a python function to find the smallest missing number from a sorted list of natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_First_Missing (My_Array : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_First_Missing;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_Array : Integer_Array) return Integer renames Placeholder.Find_First_Missing;\n\nbegin\n   pragma Assert (Candidate ((0, 1, 2, 3)) = 4);\n   pragma Assert (Candidate ((0, 1, 2, 6, 9)) = 3);\n   pragma Assert (Candidate ((2, 3, 5, 8, 9)) = 0);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_628_replace_spaces", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Replace_Spaces (My_String : Unbounded_String) return Unbounded_String;\n   -- Write a function to replace all spaces in the given string with '%20'.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Replace_Spaces (My_String : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_628_replace_spaces.py", "prompt_terminology": "verbatim", "tests": "\n   end Replace_Spaces;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Unbounded_String renames Placeholder.Replace_Spaces;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"My Name is Dawood\")) = To_Unbounded_String (\"My%20Name%20is%20Dawood\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"I am a Programmer\")) = To_Unbounded_String (\"I%20am%20a%20Programmer\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"I love Coding\")) = To_Unbounded_String (\"I%20love%20Coding\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_629_Split", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Split (List : Integer_Array) return Integer_Array;\n   -- Write a python function to find even numbers from a list of numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Split (List : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "verbatim", "tests": "\n   end Split;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List : Integer_Array) return Integer_Array renames Placeholder.Split;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5)) = (2, 4));\n   pragma Assert (Candidate ((4, 5, 6, 7, 8, 0, 1)) = (4, 6, 8, 0));\n   pragma Assert (Candidate ((8, 12, 15, 19)) = (8, 12));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_62_smallest_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Smallest_Num (Xs : Integer_Array) return Integer;\n   -- Write a python function to find smallest number in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Smallest_Num (Xs : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Smallest_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Xs : Integer_Array) return Integer renames Placeholder.Smallest_Num;\n\nbegin\n   pragma Assert (Candidate ((10, 20, 1, 45, 99)) = 1);\n   pragma Assert (Candidate ((1, 2, 3)) = 1);\n   pragma Assert (Candidate ((45, 46, 50, 60)) = 45);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_630_get_coordinates", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Get_Coordinates (Test_Tup : Integer_Integer_Tuple) return Integer_Array_Array;\n   -- Write a function to extract all the adjacent coordinates of the given coordinate tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Coordinates (Test_Tup : Integer_Integer_Tuple) return Integer_Array_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Coordinates;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup : Integer_Integer_Tuple) return Integer_Array_Array renames Placeholder.Get_Coordinates;\n\nbegin\n   pragma Assert (Candidate ((3, 4)) = ((2, 3), (2, 4), (2, 5), (3, 3), (3, 4), (3, 5), (4, 3), (4, 4), (4, 5)));\n   pragma Assert (Candidate ((4, 5)) = ((3, 4), (3, 5), (3, 6), (4, 4), (4, 5), (4, 6), (5, 4), (5, 5), (5, 6)));\n   pragma Assert (Candidate ((5, 6)) = ((4, 5), (4, 6), (4, 7), (5, 5), (5, 6), (5, 7), (6, 5), (6, 6), (6, 7)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_631_replace_spaces", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Replace_Spaces (Text : Unbounded_String) return Unbounded_String;\n   -- Write a function to replace whitespaces with an underscore and vice versa in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Replace_Spaces (Text : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "verbatim", "tests": "\n   end Replace_Spaces;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Unbounded_String renames Placeholder.Replace_Spaces;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Jumanji The Jungle\")) = To_Unbounded_String (\"Jumanji_The_Jungle\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"The_Avengers\")) = To_Unbounded_String (\"The Avengers\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Fast and Furious\")) = To_Unbounded_String (\"Fast_and_Furious\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_632_move_zero", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Move_Zero (Num_List : Integer_Array) return Integer_Array;\n   -- Write a python function to move all zeroes to the end of the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Move_Zero (Num_List : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "verbatim", "tests": "\n   end Move_Zero;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num_List : Integer_Array) return Integer_Array renames Placeholder.Move_Zero;\n\nbegin\n   pragma Assert (Candidate ((1, 0, 2, 0, 3, 4)) = (1, 2, 3, 4, 0, 0));\n   pragma Assert (Candidate ((2, 3, 2, 0, 0, 4, 0, 5, 0)) = (2, 3, 2, 4, 5, 0, 0, 0, 0));\n   pragma Assert (Candidate ((0, 1, 0, 1, 1)) = (1, 1, 1, 0, 0));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_633_pair_xor_Sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Pair_Xor_Sum (Arr : Integer_Array; N : Integer) return Integer;\n   -- Write a python function to find the sum of xor of all pairs of numbers in the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Pair_Xor_Sum (Arr : Integer_Array; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Pair_Xor_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; N : Integer) return Integer renames Placeholder.Pair_Xor_Sum;\n\nbegin\n   pragma Assert (Candidate ((5, 9, 7, 6), 4) = 47);\n   pragma Assert (Candidate ((7, 3, 5), 3) = 12);\n   pragma Assert (Candidate ((7, 3), 2) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_635_heap_sort", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Heap_Sort (Iterable : Integer_Array) return Integer_Array;\n   -- Write a function to sort the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Heap_Sort (Iterable : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "verbatim", "tests": "\n   end Heap_Sort;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Iterable : Integer_Array) return Integer_Array renames Placeholder.Heap_Sort;\n\nbegin\n   pragma Assert (Candidate ((1, 3, 5, 7, 9, 2, 4, 6, 8, 0)) = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9));\n   pragma Assert (Candidate ((25, 35, 22, 85, 14, 65, 75, 25, 58)) = (14, 22, 25, 25, 35, 58, 65, 75, 85));\n   pragma Assert (Candidate ((7, 1, 9, 5)) = (1, 5, 7, 9));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_637_noprofit_noloss", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Noprofit_Noloss (Actual_Cost : Integer; Sale_Amount : Integer) return Boolean;\n   -- Write a function to check whether the given amount has no profit and no loss\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Noprofit_Noloss (Actual_Cost : Integer; Sale_Amount : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "verbatim", "tests": "\n   end Noprofit_Noloss;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Actual_Cost : Integer; Sale_Amount : Integer) return Boolean renames Placeholder.Noprofit_Noloss;\n\nbegin\n   pragma Assert (Candidate (1500, 1200) = False);\n   pragma Assert (Candidate (100, 100) = True);\n   pragma Assert (Candidate (2000, 5000) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_638_wind_chill", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Wind_Chill (V : Integer; T : Integer) return Integer;\n   -- Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Wind_Chill (V : Integer; T : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "verbatim", "tests": "\n   end Wind_Chill;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (V : Integer; T : Integer) return Integer renames Placeholder.Wind_Chill;\n\nbegin\n   pragma Assert (Candidate (120, 35) = 40);\n   pragma Assert (Candidate (40, 20) = 19);\n   pragma Assert (Candidate (10, 8) = 6);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_639_sample_nam", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Sample_Nam (Sample_Names : Unbounded_String_Array) return Integer;\n   -- Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sample_Nam (Sample_Names : Unbounded_String_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "verbatim", "tests": "\n   end Sample_Nam;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Sample_Names : Unbounded_String_Array) return Integer renames Placeholder.Sample_Nam;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"sally\"), To_Unbounded_String (\"Dylan\"), To_Unbounded_String (\"rebecca\"), To_Unbounded_String (\"Diana\"), To_Unbounded_String (\"Joanne\"), To_Unbounded_String (\"keith\"))) = 16);\n   pragma Assert (Candidate ((To_Unbounded_String (\"php\"), To_Unbounded_String (\"res\"), To_Unbounded_String (\"Python\"), To_Unbounded_String (\"abcd\"), To_Unbounded_String (\"Java\"), To_Unbounded_String (\"aaa\"))) = 10);\n   pragma Assert (Candidate ((To_Unbounded_String (\"abcd\"), To_Unbounded_String (\"Python\"), To_Unbounded_String (\"abba\"), To_Unbounded_String (\"aba\"))) = 6);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_63_max_difference", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Max_Difference (Test_List : Integer_Integer_Tuple_Array) return Integer;\n   -- Write a function to find the maximum difference between available pairs in the given tuple list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Difference (Test_List : Integer_Integer_Tuple_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Difference;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Integer_Tuple_Array) return Integer renames Placeholder.Max_Difference;\n\nbegin\n   pragma Assert (Candidate (((3, 5), (1, 7), (10, 3), (1, 2))) = 7);\n   pragma Assert (Candidate (((4, 6), (2, 17), (9, 13), (11, 12))) = 15);\n   pragma Assert (Candidate (((12, 35), (21, 27), (13, 23), (41, 22))) = 23);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_640_remove_parenthesis", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Remove_Parenthesis (Items : Unbounded_String_Array) return Unbounded_String;\n   -- Write a function to remove the parenthesis and what is inbetween them from a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Parenthesis (Items : Unbounded_String_Array) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Parenthesis;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Items : Unbounded_String_Array) return Unbounded_String renames Placeholder.Remove_Parenthesis;\n\nbegin\n   pragma Assert (Candidate ((0 => To_Unbounded_String (\"python (chrome)\"))) = To_Unbounded_String (\"python\"));\n   pragma Assert (Candidate ((0 => To_Unbounded_String (\"string(.abc)\"))) = To_Unbounded_String (\"string\"));\n   pragma Assert (Candidate ((0 => To_Unbounded_String (\"alpha(num)\"))) = To_Unbounded_String (\"alpha\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_641_is_nonagonal", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Nonagonal (N : Integer) return Integer;\n   -- Write a function to find the nth nonagonal number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Nonagonal (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Nonagonal;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Is_Nonagonal;\n\nbegin\n   pragma Assert (Candidate (10) = 325);\n   pragma Assert (Candidate (15) = 750);\n   pragma Assert (Candidate (18) = 1089);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_643_text_match_wordz_middle", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Match_Wordz_Middle (Text : Unbounded_String) return Boolean;\n   -- Write a function that checks if a strings contains 'z', except at the start and end of the word.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Match_Wordz_Middle (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Match_Wordz_Middle;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Match_Wordz_Middle;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"pythonzabc.\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"zxyabc.\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"  lang  .\")) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Reverse_Array_Upto_K (Input : Integer_Array; K : Integer) return Integer_Array;\n   -- Write a python function to reverse an array upto a given position.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Reverse_Array_Upto_K (Input : Integer_Array; K : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "verbatim", "tests": "\n   end Reverse_Array_Upto_K;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Input : Integer_Array; K : Integer) return Integer_Array renames Placeholder.Reverse_Array_Upto_K;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6), 4) = (4, 3, 2, 1, 5, 6));\n   pragma Assert (Candidate ((4, 5, 6, 7), 2) = (5, 4, 6, 7));\n   pragma Assert (Candidate ((9, 8, 7, 6, 5), 3) = (7, 8, 9, 6, 5));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_64_subject_marks", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Integer_Tuple_Array is array (Integer range <>) of Unbounded_String_Integer_Tuple;\n   type Unbounded_String_Integer_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Integer_2 : Integer;\n   end record;\n\n   function Subject_Marks (Subjectmarks : Unbounded_String_Integer_Tuple_Array) return Unbounded_String_Integer_Tuple_Array;\n   -- Write a function to sort a list of tuples using the second value of each tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Subject_Marks (Subjectmarks : Unbounded_String_Integer_Tuple_Array) return Unbounded_String_Integer_Tuple_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "verbatim", "tests": "\n   end Subject_Marks;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Subjectmarks : Unbounded_String_Integer_Tuple_Array) return Unbounded_String_Integer_Tuple_Array renames Placeholder.Subject_Marks;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"English\"), 88), (To_Unbounded_String (\"Science\"), 90), (To_Unbounded_String (\"Maths\"), 97), (To_Unbounded_String (\"Social sciences\"), 82))) = ((To_Unbounded_String (\"Social sciences\"), 82), (To_Unbounded_String (\"English\"), 88), (To_Unbounded_String (\"Science\"), 90), (To_Unbounded_String (\"Maths\"), 97)));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Telugu\"), 49), (To_Unbounded_String (\"Hindhi\"), 54), (To_Unbounded_String (\"Social\"), 33))) = ((To_Unbounded_String (\"Social\"), 33), (To_Unbounded_String (\"Telugu\"), 49), (To_Unbounded_String (\"Hindhi\"), 54)));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Physics\"), 96), (To_Unbounded_String (\"Chemistry\"), 97), (To_Unbounded_String (\"Biology\"), 45))) = ((To_Unbounded_String (\"Biology\"), 45), (To_Unbounded_String (\"Physics\"), 96), (To_Unbounded_String (\"Chemistry\"), 97)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_66_pos_count", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Pos_Count (List : Integer_Array) return Integer;\n   -- Write a python function to count the number of positive numbers in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Pos_Count (List : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "verbatim", "tests": "\n   end Pos_Count;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List : Integer_Array) return Integer renames Placeholder.Pos_Count;\n\nbegin\n   pragma Assert (Candidate ((1, -2, 3, -4)) = 2);\n   pragma Assert (Candidate ((3, 4, 5, -1)) = 3);\n   pragma Assert (Candidate ((1, 2, 3, 4)) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_67_bell_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Bell_Number (N : Integer) return Integer;\n   -- Write a function to find the number of ways to partition a set of Bell numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Bell_Number (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Bell_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Bell_Number;\n\nbegin\n   pragma Assert (Candidate (2) = 2);\n   pragma Assert (Candidate (10) = 115975);\n   pragma Assert (Candidate (56) = 6775685320645824322581483068371419745979053216268760300);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_68_is_Monotonic", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Is_Monotonic (A : Integer_Array) return Boolean;\n   -- Write a python function to check whether the given array is monotonic or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Monotonic (A : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Monotonic;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array) return Boolean renames Placeholder.Is_Monotonic;\n\nbegin\n   pragma Assert (Candidate ((6, 5, 4, 4)) = True);\n   pragma Assert (Candidate ((1, 2, 2, 3)) = True);\n   pragma Assert (Candidate ((1, 3, 2)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_69_is_sublist", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Is_Sublist (L : Integer_Array; S : Integer_Array) return Boolean;\n   -- Write a function to check whether a list contains the given sublist or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Sublist (L : Integer_Array; S : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Sublist;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer_Array; S : Integer_Array) return Boolean renames Placeholder.Is_Sublist;\n\nbegin\n   pragma Assert (Candidate ((2, 4, 3, 5, 7), (3, 7)) = False);\n   pragma Assert (Candidate ((2, 4, 3, 5, 7), (4, 3)) = True);\n   pragma Assert (Candidate ((2, 4, 3, 5, 7), (1, 6)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Differ_At_One_Bit_Pos (A : Integer; B : Integer) return Boolean;\n   -- Write a python function to check whether the two numbers differ at one bit position only or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Differ_At_One_Bit_Pos (A : Integer; B : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "verbatim", "tests": "\n   end Differ_At_One_Bit_Pos;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Boolean renames Placeholder.Differ_At_One_Bit_Pos;\n\nbegin\n   pragma Assert (Candidate (13, 9) = True);\n   pragma Assert (Candidate (15, 8) = False);\n   pragma Assert (Candidate (2, 4) = False);\n   pragma Assert (Candidate (2, 3) = True);\n   pragma Assert (Candidate (5, 1) = True);\n   pragma Assert (Candidate (1, 5) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_70_get_equal", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Get_Equal (Input : Integer_Array_Array) return Boolean;\n   -- Write a function to find whether all the given lists have equal length or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Equal (Input : Integer_Array_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_70_get_equal.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Equal;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Input : Integer_Array_Array) return Boolean renames Placeholder.Get_Equal;\n\nbegin\n   pragma Assert (Candidate (((11, 22, 33), (44, 55, 66))) = True);\n   pragma Assert (Candidate (((1, 2, 3), (4, 5, 6, 7))) = False);\n   pragma Assert (Candidate (((1, 2), (3, 4))) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_71_comb_sort", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Comb_Sort (Nums : Integer_Array) return Integer_Array;\n   -- Write a function to sort a list of elements.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Comb_Sort (Nums : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "verbatim", "tests": "\n   end Comb_Sort;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer_Array renames Placeholder.Comb_Sort;\n\nbegin\n   pragma Assert (Candidate ((5, 15, 37, 25, 79)) = (5, 15, 25, 37, 79));\n   pragma Assert (Candidate ((41, 32, 15, 19, 22)) = (15, 19, 22, 32, 41));\n   pragma Assert (Candidate ((99, 15, 13, 47)) = (13, 15, 47, 99));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_721_maxAverageOfPath", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Max_Average_Of_Path (Cost : Integer_Array_Array) return Float;\n   -- Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Average_Of_Path (Cost : Integer_Array_Array) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Average_Of_Path;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Cost : Integer_Array_Array) return Float renames Placeholder.Max_Average_Of_Path;\n\nbegin\n   pragma Assert (Candidate (((1, 2, 3), (6, 5, 4), (7, 3, 9))) = 5.2);\n   pragma Assert (Candidate (((2, 3, 4), (7, 6, 5), (8, 4, 10))) = 6.2);\n   pragma Assert (Candidate (((3, 4, 5), (8, 7, 6), (9, 5, 11))) = 7.2);\n   pragma Assert (Candidate (((1, 2, 3), (4, 5, 6), (7, 8, 9))) = 5.8);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_723_count_same_pair", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Count_Same_Pair (Nums1 : Integer_Array; Nums2 : Integer_Array) return Integer;\n   -- The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Same_Pair (Nums1 : Integer_Array; Nums2 : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_723_count_same_pair.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Same_Pair;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums1 : Integer_Array; Nums2 : Integer_Array) return Integer renames Placeholder.Count_Same_Pair;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8), (2, 2, 3, 1, 2, 6, 7, 9)) = 4);\n   pragma Assert (Candidate ((0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8), (2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8)) = 11);\n   pragma Assert (Candidate ((2, 4, -6, -9, 11, -12, 14, -5, 17), (2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8)) = 1);\n   pragma Assert (Candidate ((0, 1, 1, 2), (0, 1, 2, 2)) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_724_power_base_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Power_Base_Sum (Base : Integer; Power : Integer) return Integer;\n   -- Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Power_Base_Sum (Base : Integer; Power : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Power_Base_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Base : Integer; Power : Integer) return Integer renames Placeholder.Power_Base_Sum;\n\nbegin\n   pragma Assert (Candidate (2, 100) = 115);\n   pragma Assert (Candidate (8, 10) = 37);\n   pragma Assert (Candidate (8, 15) = 62);\n   pragma Assert (Candidate (3, 3) = 9);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_728_sum_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Sum_List (Lst1 : Integer_Array; Lst2 : Integer_Array) return Integer_Array;\n   -- Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_List (Lst1 : Integer_Array; Lst2 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_728_sum_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Lst1 : Integer_Array; Lst2 : Integer_Array) return Integer_Array renames Placeholder.Sum_List;\n\nbegin\n   pragma Assert (Candidate ((10, 20, 30), (15, 25, 35)) = (25, 45, 65));\n   pragma Assert (Candidate ((1, 2, 3), (5, 6, 7)) = (6, 8, 10));\n   pragma Assert (Candidate ((15, 20, 30), (15, 45, 75)) = (30, 65, 105));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_72_dif_Square", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Dif_Square (N : Integer) return Boolean;\n   -- Write a python function to check whether the given number can be represented as the difference of two squares or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Dif_Square (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "verbatim", "tests": "\n   end Dif_Square;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Dif_Square;\n\nbegin\n   pragma Assert (Candidate (5) = True);\n   pragma Assert (Candidate (10) = False);\n   pragma Assert (Candidate (15) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_731_lateralsurface_cone", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Lateralsurface_Cone (R : Integer; H : Integer) return Float;\n   -- Write a function to find the lateral surface area of a cone given radius r and the height h.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Lateralsurface_Cone (R : Integer; H : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_731_lateralsurface_cone.py", "prompt_terminology": "verbatim", "tests": "\n   end Lateralsurface_Cone;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (R : Integer; H : Integer) return Float renames Placeholder.Lateralsurface_Cone;\n\nbegin\n   pragma Assert (Candidate (5, 12) = 204.20352248333654);\n   pragma Assert (Candidate (10, 15) = 566.3586699569488);\n   pragma Assert (Candidate (19, 17) = 1521.8090132193388);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_732_replace_specialchar", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Replace_Specialchar (Text : Unbounded_String) return Unbounded_String;\n   -- Write a function to replace all occurrences of spaces, commas, or dots with a colon.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Replace_Specialchar (Text : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "verbatim", "tests": "\n   end Replace_Specialchar;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Unbounded_String renames Placeholder.Replace_Specialchar;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Python language, Programming language.\")) = To_Unbounded_String (\"Python:language::Programming:language:\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"a b c,d e f\")) = To_Unbounded_String (\"a:b:c:d:e:f\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"ram reshma,ram rahim\")) = To_Unbounded_String (\"ram:reshma:ram:rahim\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_733_find_first_occurrence", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_First_Occurrence (A : Integer_Array; X : Integer) return Integer;\n   -- Write a function to find the index of the first occurrence of a given number in a sorted array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_First_Occurrence (A : Integer_Array; X : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_First_Occurrence;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; X : Integer) return Integer renames Placeholder.Find_First_Occurrence;\n\nbegin\n   pragma Assert (Candidate ((2, 5, 5, 5, 6, 6, 8, 9, 9, 9), 5) = 1);\n   pragma Assert (Candidate ((2, 3, 5, 5, 6, 6, 8, 9, 9, 9), 5) = 2);\n   pragma Assert (Candidate ((2, 4, 1, 5, 6, 6, 8, 9, 9, 9), 6) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Sum_Of_Subarray_Prod (Arr : Integer_Array) return Integer;\n   -- Write a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_Of_Subarray_Prod (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_Of_Subarray_Prod;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Sum_Of_Subarray_Prod;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = 20);\n   pragma Assert (Candidate ((1, 2)) = 5);\n   pragma Assert (Candidate ((1, 2, 3, 4)) = 84);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_735_toggle_middle_bits", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Toggle_Middle_Bits (N : Integer) return Integer;\n   -- Write a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Toggle_Middle_Bits (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "verbatim", "tests": "\n   end Toggle_Middle_Bits;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Toggle_Middle_Bits;\n\nbegin\n   pragma Assert (Candidate (9) = 15);\n   pragma Assert (Candidate (10) = 12);\n   pragma Assert (Candidate (11) = 13);\n   pragma Assert (Candidate (65) = 127);\n   pragma Assert (Candidate (77) = 115);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_736_left_insertion", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Left_Insertion (A : Integer_Array; X : Integer) return Integer;\n   -- Write a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Left_Insertion (A : Integer_Array; X : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "verbatim", "tests": "\n   end Left_Insertion;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; X : Integer) return Integer renames Placeholder.Left_Insertion;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 4, 5), 6) = 4);\n   pragma Assert (Candidate ((1, 2, 4, 5), 3) = 2);\n   pragma Assert (Candidate ((1, 2, 4, 5), 7) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_737_check_str", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Check_Str (My_String : Unbounded_String) return Boolean;\n   -- Write a function to check whether the given string is starting with a vowel or not using regex.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Str (My_String : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Str;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (My_String : Unbounded_String) return Boolean renames Placeholder.Check_Str;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"annie\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"dawood\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"Else\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_738_geometric_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Geometric_Sum (N : Integer) return Float;\n   -- Write a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Geometric_Sum (N : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Geometric_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Float renames Placeholder.Geometric_Sum;\n\nbegin\n   pragma Assert (Candidate (7) = 1.9921875);\n   pragma Assert (Candidate (4) = 1.9375);\n   pragma Assert (Candidate (8) = 1.99609375);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_739_find_Index", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Index (N : Integer) return Integer;\n   -- Write a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Index (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Index;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Find_Index;\n\nbegin\n   pragma Assert (Candidate (2) = 4);\n   pragma Assert (Candidate (3) = 14);\n   pragma Assert (Candidate (4) = 45);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_741_all_Characters_Same", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function All_Characters_Same (S : Unbounded_String) return Boolean;\n   -- Write a python function to check whether all the characters are same or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function All_Characters_Same (S : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "verbatim", "tests": "\n   end All_Characters_Same;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String) return Boolean renames Placeholder.All_Characters_Same;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"aaa\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"data\")) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_742_area_tetrahedron", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Area_Tetrahedron (Side : Integer) return Float;\n   -- Write a function to caluclate the area of a tetrahedron.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Area_Tetrahedron (Side : Integer) return Float", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_742_area_tetrahedron.py", "prompt_terminology": "verbatim", "tests": "\n   end Area_Tetrahedron;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Side : Integer) return Float renames Placeholder.Area_Tetrahedron;\n\nbegin\n   pragma Assert (Candidate (3) = 15.588457268119894);\n   pragma Assert (Candidate (20) = 692.8203230275509);\n   pragma Assert (Candidate (10) = 173.20508075688772);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_743_rotate_right", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Rotate_Right (List : Integer_Array; M : Integer) return Integer_Array;\n   -- Write a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Rotate_Right (List : Integer_Array; M : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "verbatim", "tests": "\n   end Rotate_Right;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List : Integer_Array; M : Integer) return Integer_Array renames Placeholder.Rotate_Right;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 3) = (8, 9, 10, 1, 2, 3, 4, 5, 6, 7));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 2) = (9, 10, 1, 2, 3, 4, 5, 6, 7, 8));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10), 5) = (6, 7, 8, 9, 10, 1, 2, 3, 4, 5));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_745_divisible_by_digits", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Divisible_By_Digits (Startnum : Integer; Endnum : Integer) return Integer_Array;\n   -- Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Divisible_By_Digits (Startnum : Integer; Endnum : Integer) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "verbatim", "tests": "\n   end Divisible_By_Digits;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Startnum : Integer; Endnum : Integer) return Integer_Array renames Placeholder.Divisible_By_Digits;\n\nbegin\n   pragma Assert (Candidate (1, 22) = (1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22));\n   pragma Assert (Candidate (1, 15) = (1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15));\n   pragma Assert (Candidate (20, 25) = (22, 24));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_746_sector_area", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Float_Option (Valid : Boolean := False) is record\n   case Valid is\n      when True =>\n         Value : Float;\n      when False =>\n         null;\n   end case;\nend record;\n   function Sector_Area (R : Integer; A : Integer) return Float_Option;\n   -- Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sector_Area (R : Integer; A : Integer) return Float_Option", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "verbatim", "tests": "\n   end Sector_Area;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (R : Integer; A : Integer) return Float_Option renames Placeholder.Sector_Area;\n\nbegin\n   pragma Assert (Candidate (4, 45) = (Valid => True, Value => 6.283185307179586));\n   pragma Assert (Candidate (9, 45) = (Valid => True, Value => 31.808625617596654));\n   pragma Assert (Candidate (9, 361) = (Valid => False));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_747_lcs_of_three", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Lcs_Of_Three (X : Unbounded_String; Y : Unbounded_String; Z : Unbounded_String) return Integer;\n   -- Write a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Lcs_Of_Three (X : Unbounded_String; Y : Unbounded_String; Z : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "verbatim", "tests": "\n   end Lcs_Of_Three;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (X : Unbounded_String; Y : Unbounded_String; Z : Unbounded_String) return Integer renames Placeholder.Lcs_Of_Three;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"AGGT12\"), To_Unbounded_String (\"12TXAYB\"), To_Unbounded_String (\"12XBA\")) = 2);\n   pragma Assert (Candidate (To_Unbounded_String (\"Reels\"), To_Unbounded_String (\"Reelsfor\"), To_Unbounded_String (\"ReelsforReels\")) = 5);\n   pragma Assert (Candidate (To_Unbounded_String (\"abcd1e2\"), To_Unbounded_String (\"bc12ea\"), To_Unbounded_String (\"bd1ea\")) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_748_capital_words_spaces", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Capital_Words_Spaces (Str1 : Unbounded_String) return Unbounded_String;\n   -- Write a function to put spaces between words starting with capital letters in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Capital_Words_Spaces (Str1 : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "verbatim", "tests": "\n   end Capital_Words_Spaces;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String) return Unbounded_String renames Placeholder.Capital_Words_Spaces;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Python\")) = To_Unbounded_String (\"Python\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"PythonProgrammingExamples\")) = To_Unbounded_String (\"Python Programming Examples\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"GetReadyToBeCodingFreak\")) = To_Unbounded_String (\"Get Ready To Be Coding Freak\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_749_sort_numeric_strings", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Sort_Numeric_Strings (Nums_Str : Unbounded_String_Array) return Integer_Array;\n   -- Write a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sort_Numeric_Strings (Nums_Str : Unbounded_String_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_749_sort_numeric_strings.py", "prompt_terminology": "verbatim", "tests": "\n   end Sort_Numeric_Strings;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums_Str : Unbounded_String_Array) return Integer_Array renames Placeholder.Sort_Numeric_Strings;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"4\"), To_Unbounded_String (\"12\"), To_Unbounded_String (\"45\"), To_Unbounded_String (\"7\"), To_Unbounded_String (\"0\"), To_Unbounded_String (\"100\"), To_Unbounded_String (\"200\"), To_Unbounded_String (\"-12\"), To_Unbounded_String (\"-500\"))) = (-500, -12, 0, 4, 7, 12, 45, 100, 200));\n   pragma Assert (Candidate ((To_Unbounded_String (\"2\"), To_Unbounded_String (\"3\"), To_Unbounded_String (\"8\"), To_Unbounded_String (\"4\"), To_Unbounded_String (\"7\"), To_Unbounded_String (\"9\"), To_Unbounded_String (\"8\"), To_Unbounded_String (\"2\"), To_Unbounded_String (\"6\"), To_Unbounded_String (\"5\"), To_Unbounded_String (\"1\"), To_Unbounded_String (\"6\"), To_Unbounded_String (\"1\"), To_Unbounded_String (\"2\"), To_Unbounded_String (\"3\"), To_Unbounded_String (\"4\"), To_Unbounded_String (\"6\"), To_Unbounded_String (\"9\"), To_Unbounded_String (\"1\"), To_Unbounded_String (\"2\"))) = (1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9));\n   pragma Assert (Candidate ((To_Unbounded_String (\"1\"), To_Unbounded_String (\"3\"), To_Unbounded_String (\"5\"), To_Unbounded_String (\"7\"), To_Unbounded_String (\"1\"), To_Unbounded_String (\"3\"), To_Unbounded_String (\"13\"), To_Unbounded_String (\"15\"), To_Unbounded_String (\"17\"), To_Unbounded_String (\"5\"), To_Unbounded_String (\"7 \"), To_Unbounded_String (\"9\"), To_Unbounded_String (\"1\"), To_Unbounded_String (\"11\"))) = (1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_74_is_samepatterns", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Is_Samepatterns (Colors : Unbounded_String_Array; Patterns : Unbounded_String_Array) return Boolean;\n   -- Write a function to check whether it follows the sequence given in the patterns array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Samepatterns (Colors : Unbounded_String_Array; Patterns : Unbounded_String_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_74_is_samepatterns.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Samepatterns;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Colors : Unbounded_String_Array; Patterns : Unbounded_String_Array) return Boolean renames Placeholder.Is_Samepatterns;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"red\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"green\")), (To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\"), To_Unbounded_String (\"b\"))) = True);\n   pragma Assert (Candidate ((To_Unbounded_String (\"red\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"greenn\")), (To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\"), To_Unbounded_String (\"b\"))) = False);\n   pragma Assert (Candidate ((To_Unbounded_String (\"red\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"greenn\")), (To_Unbounded_String (\"a\"), To_Unbounded_String (\"b\"))) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_750_add_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Add_Tuple (Test_List : Integer_Array; Test_Tup : Integer_Integer_Tuple) return Integer_Array;\n   -- Write a function to add the given tuple to the given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Add_Tuple (Test_List : Integer_Array; Test_Tup : Integer_Integer_Tuple) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end Add_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Array; Test_Tup : Integer_Integer_Tuple) return Integer_Array renames Placeholder.Add_Tuple;\n\nbegin\n   pragma Assert (Candidate ((5, 6, 7), (9, 10)) = (5, 6, 7, 9, 10));\n   pragma Assert (Candidate ((6, 7, 8), (10, 11)) = (6, 7, 8, 10, 11));\n   pragma Assert (Candidate ((7, 8, 9), (11, 12)) = (7, 8, 9, 11, 12));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_751_check_min_heap", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Check_Min_Heap (Arr : Integer_Array) return Boolean;\n   -- Write a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Min_Heap (Arr : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Min_Heap;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Boolean renames Placeholder.Check_Min_Heap;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6)) = True);\n   pragma Assert (Candidate ((2, 3, 4, 5, 10, 15)) = True);\n   pragma Assert (Candidate ((2, 10, 4, 5, 3, 15)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_752_jacobsthal_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Jacobsthal_Num (N : Integer) return Integer;\n   -- Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Jacobsthal_Num (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Jacobsthal_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Jacobsthal_Num;\n\nbegin\n   pragma Assert (Candidate (5) = 11);\n   pragma Assert (Candidate (2) = 1);\n   pragma Assert (Candidate (4) = 5);\n   pragma Assert (Candidate (13) = 2731);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_753_min_k", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Integer_Tuple_Array is array (Integer range <>) of Unbounded_String_Integer_Tuple;\n   type Unbounded_String_Integer_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Integer_2 : Integer;\n   end record;\n\n   function Min_K (Test_List : Unbounded_String_Integer_Tuple_Array; K : Integer) return Unbounded_String_Integer_Tuple_Array;\n   -- Write a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Min_K (Test_List : Unbounded_String_Integer_Tuple_Array; K : Integer) return Unbounded_String_Integer_Tuple_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "verbatim", "tests": "\n   end Min_K;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Unbounded_String_Integer_Tuple_Array; K : Integer) return Unbounded_String_Integer_Tuple_Array renames Placeholder.Min_K;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"Manjeet\"), 10), (To_Unbounded_String (\"Akshat\"), 4), (To_Unbounded_String (\"Akash\"), 2), (To_Unbounded_String (\"Nikhil\"), 8)), 2) = ((To_Unbounded_String (\"Akash\"), 2), (To_Unbounded_String (\"Akshat\"), 4)));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Sanjeev\"), 11), (To_Unbounded_String (\"Angat\"), 5), (To_Unbounded_String (\"Akash\"), 3), (To_Unbounded_String (\"Nepin\"), 9)), 3) = ((To_Unbounded_String (\"Akash\"), 3), (To_Unbounded_String (\"Angat\"), 5), (To_Unbounded_String (\"Nepin\"), 9)));\n   pragma Assert (Candidate (((To_Unbounded_String (\"tanmay\"), 14), (To_Unbounded_String (\"Amer\"), 11), (To_Unbounded_String (\"Ayesha\"), 9), (To_Unbounded_String (\"SKD\"), 16)), 1) = (0 => (To_Unbounded_String (\"Ayesha\"), 9)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_756_text_match_zero_one", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Match_Zero_One (Text : Unbounded_String) return Boolean;\n   -- Write a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Match_Zero_One (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Match_Zero_One;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Match_Zero_One;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"ac\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"dc\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"abbbba\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"dsabbbba\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"asbbbba\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"abaaa\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_757_count_reverse_pairs", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Count_Reverse_Pairs (Test_List : Unbounded_String_Array) return Integer;\n   -- Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Reverse_Pairs (Test_List : Unbounded_String_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Reverse_Pairs;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Unbounded_String_Array) return Integer renames Placeholder.Count_Reverse_Pairs;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"julia\"), To_Unbounded_String (\"best\"), To_Unbounded_String (\"tseb\"), To_Unbounded_String (\"for\"), To_Unbounded_String (\"ailuj\"))) = 2);\n   pragma Assert (Candidate ((To_Unbounded_String (\"geeks\"), To_Unbounded_String (\"best\"), To_Unbounded_String (\"for\"), To_Unbounded_String (\"skeeg\"))) = 1);\n   pragma Assert (Candidate ((To_Unbounded_String (\"makes\"), To_Unbounded_String (\"best\"), To_Unbounded_String (\"sekam\"), To_Unbounded_String (\"for\"), To_Unbounded_String (\"rof\"))) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_759_is_decimal", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Decimal (Num : Unbounded_String) return Boolean;\n   -- Write a function to check whether a given string is a decimal number with a precision of 2.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Decimal (Num : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Decimal;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Num : Unbounded_String) return Boolean renames Placeholder.Is_Decimal;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"123.11\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"e666.86\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"3.124587\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"1.11\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"1.1.11\")) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_75_find_tuples", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Integer_Tuple;\n   type Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Find_Tuples (Test_List : Integer_Integer_Integer_Tuple_Array; K : Integer) return Integer_Integer_Integer_Tuple_Array;\n   -- Write a function to find tuples which have all elements divisible by k from the given list of tuples.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Tuples (Test_List : Integer_Integer_Integer_Tuple_Array; K : Integer) return Integer_Integer_Integer_Tuple_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Tuples;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Integer_Integer_Tuple_Array; K : Integer) return Integer_Integer_Integer_Tuple_Array renames Placeholder.Find_Tuples;\n\nbegin\n   pragma Assert (Candidate (((6, 24, 12), (7, 9, 6), (12, 18, 21)), 6) = (0 => (6, 24, 12)));\n   pragma Assert (Candidate (((5, 25, 30), (4, 2, 3), (7, 8, 9)), 5) = (0 => (5, 25, 30)));\n   pragma Assert (Candidate (((7, 9, 16), (8, 16, 4), (19, 17, 18)), 4) = (0 => (8, 16, 4)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_760_unique_Element", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Unique_Element (Arr : Integer_Array) return Boolean;\n   -- Write a python function to check whether a list of numbers contains only one distinct element or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Unique_Element (Arr : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "verbatim", "tests": "\n   end Unique_Element;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Boolean renames Placeholder.Unique_Element;\n\nbegin\n   pragma Assert (Candidate ((1, 1, 1)) = True);\n   pragma Assert (Candidate ((1, 2, 1, 2)) = False);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_762_check_monthnumber_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Check_Monthnumber_Number (Monthnum3 : Integer) return Boolean;\n   -- Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Monthnumber_Number (Monthnum3 : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Monthnumber_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Monthnum3 : Integer) return Boolean renames Placeholder.Check_Monthnumber_Number;\n\nbegin\n   pragma Assert (Candidate (6) = True);\n   pragma Assert (Candidate (2) = False);\n   pragma Assert (Candidate (12) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_763_find_min_diff", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Min_Diff (Arr : Integer_Array; N : Integer) return Integer;\n   -- Write a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Min_Diff (Arr : Integer_Array; N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Min_Diff;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; N : Integer) return Integer renames Placeholder.Find_Min_Diff;\n\nbegin\n   pragma Assert (Candidate ((1, 5, 3, 19, 18, 25), 6) = 1);\n   pragma Assert (Candidate ((4, 3, 2, 6), 4) = 1);\n   pragma Assert (Candidate ((30, 5, 20, 9), 4) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_764_number_ctr", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Number_Ctr (Str : Unbounded_String) return Integer;\n   -- Write a python function to count number of digits in a given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Number_Ctr (Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "verbatim", "tests": "\n   end Number_Ctr;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String) return Integer renames Placeholder.Number_Ctr;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"program2bedone\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"3wonders\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"123\")) = 3);\n   pragma Assert (Candidate (To_Unbounded_String (\"3wond-1ers2\")) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_765_is_polite", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Polite (N : Integer) return Integer;\n   -- Write a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Polite (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_765_is_polite.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Polite;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Is_Polite;\n\nbegin\n   pragma Assert (Candidate (7) = 11);\n   pragma Assert (Candidate (4) = 7);\n   pragma Assert (Candidate (9) = 13);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_766_pair_wise", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   function Pair_Wise (L1 : Integer_Array) return Integer_Integer_Tuple_Array;\n   -- Write a function to return a list of all pairs of consecutive items in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Pair_Wise (L1 : Integer_Array) return Integer_Integer_Tuple_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "verbatim", "tests": "\n   end Pair_Wise;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L1 : Integer_Array) return Integer_Integer_Tuple_Array renames Placeholder.Pair_Wise;\n\nbegin\n   pragma Assert (Candidate ((1, 1, 2, 3, 3, 4, 4, 5)) = ((1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)));\n   pragma Assert (Candidate ((1, 5, 7, 9, 10)) = ((1, 5), (5, 7), (7, 9), (9, 10)));\n   pragma Assert (Candidate ((5, 1, 9, 7, 10)) = ((5, 1), (1, 9), (9, 7), (7, 10)));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) = ((1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_767_get_pairs_count", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Get_Pairs_Count (Arr : Integer_Array; Sum : Integer) return Integer;\n   -- Write a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Pairs_Count (Arr : Integer_Array; Sum : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Pairs_Count;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; Sum : Integer) return Integer renames Placeholder.Get_Pairs_Count;\n\nbegin\n   pragma Assert (Candidate ((1, 1, 1, 1), 2) = 6);\n   pragma Assert (Candidate ((1, 5, 7, -1, 5), 6) = 3);\n   pragma Assert (Candidate ((1, -2, 3), 1) = 1);\n   pragma Assert (Candidate ((-1, -2, 3), -3) = 1);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_769_Diff", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Diff (Li1 : Integer_Array; Li2 : Integer_Array) return Integer_Array;\n   -- Write a python function to get the difference between two lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Diff (Li1 : Integer_Array; Li2 : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_769_Diff.py", "prompt_terminology": "verbatim", "tests": "\n   end Diff;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Li1 : Integer_Array; Li2 : Integer_Array) return Integer_Array renames Placeholder.Diff;\n\nbegin\n   pragma Assert (Candidate ((10, 15, 20, 25, 30, 35, 40), (25, 40, 35)) = (10, 20, 30, 15));\n   pragma Assert (Candidate ((1, 2, 3, 4, 5), (6, 7, 1)) = (2, 3, 4, 5, 6, 7));\n   pragma Assert (Candidate ((1, 2, 3), (6, 7, 1)) = (2, 3, 6, 7));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_770_odd_num_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Odd_Num_Sum (N : Integer) return Integer;\n   -- Write a python function to find the sum of fourth power of first n odd natural numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Odd_Num_Sum (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Odd_Num_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Odd_Num_Sum;\n\nbegin\n   pragma Assert (Candidate (2) = 82);\n   pragma Assert (Candidate (3) = 707);\n   pragma Assert (Candidate (4) = 3108);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_771_check_expression", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Check_Expression (Exp : Unbounded_String) return Boolean;\n   -- Write a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Expression (Exp : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Expression;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Exp : Unbounded_String) return Boolean renames Placeholder.Check_Expression;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"{()}[{}]\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"{()}[{]\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"{()}[{}][]({})\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_772_remove_length", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_Length (Test_Str : Unbounded_String; K : Integer) return Unbounded_String;\n   -- Write a function to remove all the words with k length in the given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_Length (Test_Str : Unbounded_String; K : Integer) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_Length;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Str : Unbounded_String; K : Integer) return Unbounded_String renames Placeholder.Remove_Length;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"The person is most value tet\"), 3) = To_Unbounded_String (\"person is most value\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"If you told me about this ok\"), 4) = To_Unbounded_String (\"If you me about ok\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"Forces of darkeness is come into the play\"), 4) = To_Unbounded_String (\"Forces of darkeness is the\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_773_occurance_substring", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Integer_Integer_Tuple_Option (Valid : Boolean := False) is record\n   case Valid is\n      when True =>\n         Value : Unbounded_String_Integer_Integer_Tuple;\n      when False =>\n         null;\n   end case;\nend record;\n   type Unbounded_String_Integer_Integer_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Occurance_Substring (Text : Unbounded_String; Pattern : Unbounded_String) return Unbounded_String_Integer_Integer_Tuple_Option;\n   -- Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Occurance_Substring (Text : Unbounded_String; Pattern : Unbounded_String) return Unbounded_String_Integer_Integer_Tuple_Option", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py", "prompt_terminology": "verbatim", "tests": "\n   end Occurance_Substring;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String; Pattern : Unbounded_String) return Unbounded_String_Integer_Integer_Tuple_Option renames Placeholder.Occurance_Substring;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python programming, python language\"), To_Unbounded_String (\"python\")) = (Valid => True, Value => (To_Unbounded_String (\"python\"), 0, 6)));\n   pragma Assert (Candidate (To_Unbounded_String (\"python programming,programming language\"), To_Unbounded_String (\"programming\")) = (Valid => True, Value => (To_Unbounded_String (\"programming\"), 7, 18)));\n   pragma Assert (Candidate (To_Unbounded_String (\"python programming,programming language\"), To_Unbounded_String (\"language\")) = (Valid => True, Value => (To_Unbounded_String (\"language\"), 31, 39)));\n   pragma Assert (Candidate (To_Unbounded_String (\"c++ programming, c++ language\"), To_Unbounded_String (\"python\")) = (Valid => False));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_775_odd_position", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Odd_Position (Nums : Integer_Array) return Boolean;\n   -- Write a python function to check whether every odd index contains odd numbers of a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Odd_Position (Nums : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "verbatim", "tests": "\n   end Odd_Position;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Boolean renames Placeholder.Odd_Position;\n\nbegin\n   pragma Assert (Candidate ((2, 1, 4, 3, 6, 7, 6, 3)) = True);\n   pragma Assert (Candidate ((4, 1, 2)) = True);\n   pragma Assert (Candidate ((1, 2, 3)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_776_count_vowels", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Vowels (Test_Str : Unbounded_String) return Integer;\n   -- Write a function to count those characters which have vowels as their neighbors in the given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Vowels (Test_Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Vowels;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Str : Unbounded_String) return Integer renames Placeholder.Count_Vowels;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"bestinstareels\")) = 7);\n   pragma Assert (Candidate (To_Unbounded_String (\"partofthejourneyistheend\")) = 12);\n   pragma Assert (Candidate (To_Unbounded_String (\"amazonprime\")) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_777_find_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Find_Sum (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the sum of non-repeated elements in a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Sum (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Find_Sum;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 1, 1, 4, 5, 6)) = 21);\n   pragma Assert (Candidate ((1, 10, 9, 4, 2, 10, 10, 45, 4)) = 71);\n   pragma Assert (Candidate ((12, 10, 9, 45, 2, 10, 10, 45, 10)) = 78);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_77_is_Diff", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Diff (N : Integer) return Boolean;\n   -- Write a python function to find whether a number is divisible by 11.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Diff (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Diff;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Is_Diff;\n\nbegin\n   pragma Assert (Candidate (12345) = False);\n   pragma Assert (Candidate (1212112) = True);\n   pragma Assert (Candidate (1212) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_780_find_combinations", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Tuple_Array is array (Integer range <>) of Integer_Integer_Tuple;\n   type Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n   end record;\n\n   function Find_Combinations (Test_List : Integer_Integer_Tuple_Array) return Integer_Integer_Tuple_Array;\n   -- Write a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Combinations (Test_List : Integer_Integer_Tuple_Array) return Integer_Integer_Tuple_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Combinations;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Integer_Integer_Tuple_Array) return Integer_Integer_Tuple_Array renames Placeholder.Find_Combinations;\n\nbegin\n   pragma Assert (Candidate (((2, 4), (6, 7), (5, 1), (6, 10))) = ((8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)));\n   pragma Assert (Candidate (((3, 5), (7, 8), (6, 2), (7, 11))) = ((10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)));\n   pragma Assert (Candidate (((4, 6), (8, 9), (7, 3), (8, 12))) = ((12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_781_count_divisors", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Count_Divisors (N : Integer) return Boolean;\n   -- Write a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Divisors (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Divisors;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Count_Divisors;\n\nbegin\n   pragma Assert (Candidate (10) = True);\n   pragma Assert (Candidate (100) = False);\n   pragma Assert (Candidate (125) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_782_odd_length_sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Odd_Length_Sum (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Odd_Length_Sum (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_782_odd_length_sum.py", "prompt_terminology": "verbatim", "tests": "\n   end Odd_Length_Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Odd_Length_Sum;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 4)) = 14);\n   pragma Assert (Candidate ((1, 2, 1, 2)) = 15);\n   pragma Assert (Candidate ((1, 7)) = 8);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_783_rgb_to_hsv", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Float_Array is array (Integer range <>) of Float;\n   function Rgb_To_Hsv (R : Integer; G : Integer; B : Integer) return Float_Array;\n   -- Write a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Rgb_To_Hsv (R : Integer; G : Integer; B : Integer) return Float_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "verbatim", "tests": "\n   end Rgb_To_Hsv;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (R : Integer; G : Integer; B : Integer) return Float_Array renames Placeholder.Rgb_To_Hsv;\n\nbegin\n   pragma Assert (Candidate (255, 255, 255) = (0.0, 0.0, 100.0));\n   pragma Assert (Candidate (0, 215, 0) = (120.0, 100.0, 84.31372549019608));\n   pragma Assert (Candidate (10, 215, 110) = (149.26829268292684, 95.34883720930233, 84.31372549019608));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_784_mul_even_odd", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Mul_Even_Odd (List1 : Integer_Array) return Integer;\n   -- Write a function to find the product of first even and odd number of a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Mul_Even_Odd (List1 : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "verbatim", "tests": "\n   end Mul_Even_Odd;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Integer_Array) return Integer renames Placeholder.Mul_Even_Odd;\n\nbegin\n   pragma Assert (Candidate ((1, 3, 5, 7, 4, 1, 6, 8)) = 4);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) = 2);\n   pragma Assert (Candidate ((1, 5, 7, 9, 10)) = 10);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_785_tuple_str_int", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Tuple_Str_Int (Test_Str : Unbounded_String) return Integer_Integer_Integer_Tuple;\n   -- Write a function to convert tuple string to integer tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Tuple_Str_Int (Test_Str : Unbounded_String) return Integer_Integer_Integer_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py", "prompt_terminology": "verbatim", "tests": "\n   end Tuple_Str_Int;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Str : Unbounded_String) return Integer_Integer_Integer_Tuple renames Placeholder.Tuple_Str_Int;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"(7, 8, 9)\")) = (7, 8, 9));\n   pragma Assert (Candidate (To_Unbounded_String (\"(1, 2, 3)\")) = (1, 2, 3));\n   pragma Assert (Candidate (To_Unbounded_String (\"(4, 5, 6)\")) = (4, 5, 6));\n   pragma Assert (Candidate (To_Unbounded_String (\"(7, 81, 19)\")) = (7, 81, 19));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_786_right_insertion", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Right_Insertion (A : Integer_Array; X : Integer) return Integer;\n   -- Write a function to locate the right insertion point for a specified value in sorted order.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Right_Insertion (A : Integer_Array; X : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "verbatim", "tests": "\n   end Right_Insertion;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer_Array; X : Integer) return Integer renames Placeholder.Right_Insertion;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 4, 5), 6) = 4);\n   pragma Assert (Candidate ((1, 2, 4, 5), 3) = 2);\n   pragma Assert (Candidate ((1, 2, 4, 5), 7) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_787_text_match_three", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Match_Three (Text : Unbounded_String) return Boolean;\n   -- Write a function that matches a string that has an a followed by three 'b'.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Match_Three (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_787_text_match_three.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Match_Three;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Match_Three;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"ac\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"dc\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"abbbba\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"caacabbbba\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_788_new_tuple", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   type Unbounded_String_Unbounded_String_Unbounded_String_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Unbounded_String_2 : Unbounded_String;\n     Unbounded_String_3 : Unbounded_String;\n   end record;\n\n   function New_Tuple (Test_List : Unbounded_String_Array; Test_Str : Unbounded_String) return Unbounded_String_Unbounded_String_Unbounded_String_Tuple;\n   -- Write a function to create a new tuple from the given string and list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function New_Tuple (Test_List : Unbounded_String_Array; Test_Str : Unbounded_String) return Unbounded_String_Unbounded_String_Unbounded_String_Tuple", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_788_new_tuple.py", "prompt_terminology": "verbatim", "tests": "\n   end New_Tuple;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Unbounded_String_Array; Test_Str : Unbounded_String) return Unbounded_String_Unbounded_String_Unbounded_String_Tuple renames Placeholder.New_Tuple;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"WEB\"), To_Unbounded_String (\"is\")), To_Unbounded_String (\"best\")) = (To_Unbounded_String (\"WEB\"), To_Unbounded_String (\"is\"), To_Unbounded_String (\"best\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"We\"), To_Unbounded_String (\"are\")), To_Unbounded_String (\"Developers\")) = (To_Unbounded_String (\"We\"), To_Unbounded_String (\"are\"), To_Unbounded_String (\"Developers\")));\n   pragma Assert (Candidate ((To_Unbounded_String (\"Part\"), To_Unbounded_String (\"is\")), To_Unbounded_String (\"Wrong\")) = (To_Unbounded_String (\"Part\"), To_Unbounded_String (\"is\"), To_Unbounded_String (\"Wrong\")));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_790_even_position", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Even_Position (Nums : Integer_Array) return Boolean;\n   -- Write a python function to check whether every even index contains even numbers of a given list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Even_Position (Nums : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "verbatim", "tests": "\n   end Even_Position;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Boolean renames Placeholder.Even_Position;\n\nbegin\n   pragma Assert (Candidate ((3, 2, 1)) = False);\n   pragma Assert (Candidate ((1, 2, 3)) = False);\n   pragma Assert (Candidate ((2, 1, 4)) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_792_count_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Count_List (Input_List : Integer_Array_Array) return Integer;\n   -- Write a python function to count the number of lists in a given number of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_List (Input_List : Integer_Array_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Input_List : Integer_Array_Array) return Integer renames Placeholder.Count_List;\n\nbegin\n   pragma Assert (Candidate (((1, 3), (5, 7), (9, 11), (13, 15, 17))) = 4);\n   pragma Assert (Candidate (((1, 2), (2, 3), (4, 5))) = 3);\n   pragma Assert (Candidate (((1, 0), (2, 0))) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_793_last", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Last (Arr : Integer_Array; X : Integer) return Integer;\n   -- Write a python function to find the last position of an element in a sorted array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Last (Arr : Integer_Array; X : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "verbatim", "tests": "\n   end Last;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array; X : Integer) return Integer renames Placeholder.Last;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3), 1) = 0);\n   pragma Assert (Candidate ((1, 1, 1, 2, 3, 4), 1) = 2);\n   pragma Assert (Candidate ((2, 3, 2, 3, 6, 8, 9), 3) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_794_text_starta_endb", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Text_Starta_Endb (Text : Unbounded_String) return Boolean;\n   -- Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Text_Starta_Endb (Text : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "verbatim", "tests": "\n   end Text_Starta_Endb;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Boolean renames Placeholder.Text_Starta_Endb;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"aabbbb\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"aabAbbbc\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"accddbbjjj\")) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_797_sum_in_range", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sum_In_Range (L : Integer; R : Integer) return Integer;\n   -- Write a python function to find the sum of all odd natural numbers within the range l and r.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sum_In_Range (L : Integer; R : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "verbatim", "tests": "\n   end Sum_In_Range;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (L : Integer; R : Integer) return Integer renames Placeholder.Sum_In_Range;\n\nbegin\n   pragma Assert (Candidate (2, 5) = 8);\n   pragma Assert (Candidate (5, 7) = 12);\n   pragma Assert (Candidate (7, 13) = 40);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_798__sum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function _Sum (Arr : Integer_Array) return Integer;\n   -- Write a python function to find the sum of an array.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function _Sum (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "verbatim", "tests": "\n   end _Sum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder._Sum;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = 6);\n   pragma Assert (Candidate ((15, 12, 13, 10)) = 50);\n   pragma Assert (Candidate ((0, 1, 2)) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_799_left_rotate", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Left_Rotate (N : Integer; D : Integer) return Integer;\n   -- Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Left_Rotate (N : Integer; D : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "verbatim", "tests": "\n   end Left_Rotate;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer; D : Integer) return Integer renames Placeholder.Left_Rotate;\n\nbegin\n   pragma Assert (Candidate (16, 2) = 64);\n   pragma Assert (Candidate (10, 2) = 40);\n   pragma Assert (Candidate (99, 3) = 792);\n   pragma Assert (Candidate (99, 3) = 792);\n   pragma Assert (Candidate (1, 3) = 8);\n   pragma Assert (Candidate (5, 3) = 40);\n   pragma Assert (Candidate (29, 3) = 232);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_79_word_len", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Word_Len (S : Unbounded_String) return Boolean;\n   -- Write a python function to check whether the length of the word is odd or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Word_Len (S : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "verbatim", "tests": "\n   end Word_Len;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (S : Unbounded_String) return Boolean renames Placeholder.Word_Len;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"Hadoop\")) = False);\n   pragma Assert (Candidate (To_Unbounded_String (\"great\")) = True);\n   pragma Assert (Candidate (To_Unbounded_String (\"structure\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_800_remove_all_spaces", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Remove_All_Spaces (Text : Unbounded_String) return Unbounded_String;\n   -- Write a function to remove all whitespaces from a string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Remove_All_Spaces (Text : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "verbatim", "tests": "\n   end Remove_All_Spaces;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Text : Unbounded_String) return Unbounded_String renames Placeholder.Remove_All_Spaces;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"python  program\")) = To_Unbounded_String (\"pythonprogram\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"python   programming    language\")) = To_Unbounded_String (\"pythonprogramminglanguage\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"python                     program\")) = To_Unbounded_String (\"pythonprogram\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"   python                     program\")) = To_Unbounded_String (\"pythonprogram\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_801_test_three_equal", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Test_Three_Equal (X : Integer; Y : Integer; Z : Integer) return Integer;\n   -- Write a python function to count the number of equal numbers from three given integers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Test_Three_Equal (X : Integer; Y : Integer; Z : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "verbatim", "tests": "\n   end Test_Three_Equal;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (X : Integer; Y : Integer; Z : Integer) return Integer renames Placeholder.Test_Three_Equal;\n\nbegin\n   pragma Assert (Candidate (1, 1, 1) = 3);\n   pragma Assert (Candidate (-1, -2, -3) = 0);\n   pragma Assert (Candidate (1, 2, 2) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_802_count_rotation", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Count_Rotation (Arr : Integer_Array) return Integer;\n   -- Write a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Count_Rotation (Arr : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "verbatim", "tests": "\n   end Count_Rotation;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Integer renames Placeholder.Count_Rotation;\n\nbegin\n   pragma Assert (Candidate ((3, 2, 1)) = 1);\n   pragma Assert (Candidate ((4, 5, 1, 2, 3)) = 2);\n   pragma Assert (Candidate ((7, 8, 9, 1, 2, 3)) = 3);\n   pragma Assert (Candidate ((1, 2, 3)) = 0);\n   pragma Assert (Candidate ((1, 3, 2)) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_803_is_perfect_square", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Perfect_Square (N : Integer) return Boolean;\n   -- Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Perfect_Square (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Perfect_Square;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Is_Perfect_Square;\n\nbegin\n   pragma Assert (Candidate (10) = False);\n   pragma Assert (Candidate (36) = True);\n   pragma Assert (Candidate (14) = False);\n   pragma Assert (Candidate (196) = True);\n   pragma Assert (Candidate (125) = False);\n   pragma Assert (Candidate (15625) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_804_is_product_even", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Is_Product_Even (Arr : Integer_Array) return Boolean;\n   -- Write a function to check whether the product of numbers in a list is even or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Product_Even (Arr : Integer_Array) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_804_is_product_even.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Product_Even;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Arr : Integer_Array) return Boolean renames Placeholder.Is_Product_Even;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3)) = True);\n   pragma Assert (Candidate ((1, 2, 1, 4)) = True);\n   pragma Assert (Candidate ((1, 1)) = False);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_805_max_sum_list", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Max_Sum_List (Lists : Integer_Array_Array) return Integer_Array;\n   -- Write a function that returns the list in a list of lists whose sum of elements is the highest.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Sum_List (Lists : Integer_Array_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_805_max_sum_list.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Sum_List;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Lists : Integer_Array_Array) return Integer_Array renames Placeholder.Max_Sum_List;\n\nbegin\n   pragma Assert (Candidate (((1, 2, 3), (4, 5, 6), (10, 11, 12), (7, 8, 9))) = (10, 11, 12));\n   pragma Assert (Candidate (((3, 2, 1), (6, 5, 4), (12, 11, 10))) = (12, 11, 10));\n   pragma Assert (Candidate ((0 => (2, 3, 1))) = (2, 3, 1));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_806_max_run_uppercase", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Max_Run_Uppercase (Test_Str : Unbounded_String) return Integer;\n   -- Write a function to find maximum run of uppercase characters in the given string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Max_Run_Uppercase (Test_Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "verbatim", "tests": "\n   end Max_Run_Uppercase;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Str : Unbounded_String) return Integer renames Placeholder.Max_Run_Uppercase;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"GeMKSForGERksISBESt\")) = 5);\n   pragma Assert (Candidate (To_Unbounded_String (\"PrECIOusMOVemENTSYT\")) = 6);\n   pragma Assert (Candidate (To_Unbounded_String (\"GooGLEFluTTER\")) = 4);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_807_first_odd", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function First_Odd (Nums : Integer_Array) return Integer;\n   -- Write a python function to find the first odd number in a given list of numbers.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function First_Odd (Nums : Integer_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "verbatim", "tests": "\n   end First_Odd;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer renames Placeholder.First_Odd;\n\nbegin\n   pragma Assert (Candidate ((1, 3, 5)) = 1);\n   pragma Assert (Candidate ((2, 4, 1, 3)) = 1);\n   pragma Assert (Candidate ((8, 9, 1)) = 9);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_808_check_K", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Check_K (Test_Tup : Integer_Array; K : Integer) return Boolean;\n   -- Write a function to check if the given tuples contain the k or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_K (Test_Tup : Integer_Array; K : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_K;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup : Integer_Array; K : Integer) return Boolean renames Placeholder.Check_K;\n\nbegin\n   pragma Assert (Candidate ((10, 4, 5, 6, 8), 6) = True);\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6), 7) = False);\n   pragma Assert (Candidate ((7, 8, 9, 44, 11, 12), 11) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_809_check_smaller", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Integer_Integer_Tuple is record\n     Integer_1 : Integer;\n     Integer_2 : Integer;\n     Integer_3 : Integer;\n   end record;\n\n   function Check_Smaller (Test_Tup1 : Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Tuple) return Boolean;\n   -- Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Check_Smaller (Test_Tup1 : Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Tuple) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_809_check_smaller.py", "prompt_terminology": "verbatim", "tests": "\n   end Check_Smaller;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_Tup1 : Integer_Integer_Integer_Tuple; Test_Tup2 : Integer_Integer_Integer_Tuple) return Boolean renames Placeholder.Check_Smaller;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3), (2, 3, 4)) = False);\n   pragma Assert (Candidate ((4, 5, 6), (3, 4, 5)) = True);\n   pragma Assert (Candidate ((11, 12, 13), (10, 11, 12)) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_80_tetrahedral_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Tetrahedral_Number (N : Integer) return Integer;\n   -- Write a function to find the nth tetrahedral number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Tetrahedral_Number (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Tetrahedral_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Tetrahedral_Number;\n\nbegin\n   pragma Assert (Candidate (5) = 35);\n   pragma Assert (Candidate (6) = 56);\n   pragma Assert (Candidate (7) = 84);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_83_get_Char", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Get_Char (Strr : Unbounded_String) return Unbounded_String;\n   -- Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Get_Char (Strr : Unbounded_String) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "verbatim", "tests": "\n   end Get_Char;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Strr : Unbounded_String) return Unbounded_String renames Placeholder.Get_Char;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"abc\")) = To_Unbounded_String (\"f\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"gfg\")) = To_Unbounded_String (\"t\"));\n   pragma Assert (Candidate (To_Unbounded_String (\"ab\")) = To_Unbounded_String (\"c\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_84_sequence", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Sequence (N : Integer) return Integer;\n   -- Write a function to find the nth number in the newman conway sequence.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Sequence (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "verbatim", "tests": "\n   end Sequence;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Sequence;\n\nbegin\n   pragma Assert (Candidate (10) = 6);\n   pragma Assert (Candidate (2) = 1);\n   pragma Assert (Candidate (3) = 2);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_86_centered_hexagonal_number", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Centered_Hexagonal_Number (N : Integer) return Integer;\n   -- Write a function to find nth centered hexagonal number.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Centered_Hexagonal_Number (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "verbatim", "tests": "\n   end Centered_Hexagonal_Number;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Centered_Hexagonal_Number;\n\nbegin\n   pragma Assert (Candidate (10) = 271);\n   pragma Assert (Candidate (2) = 7);\n   pragma Assert (Candidate (9) = 217);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_89_closest_num", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Closest_Num (N : Integer) return Integer;\n   -- Write a function to find the closest smaller number than n.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Closest_Num (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py", "prompt_terminology": "verbatim", "tests": "\n   end Closest_Num;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Closest_Num;\n\nbegin\n   pragma Assert (Candidate (11) = 10);\n   pragma Assert (Candidate (7) = 6);\n   pragma Assert (Candidate (12) = 11);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_8_square_nums", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   function Square_Nums (Nums : Integer_Array) return Integer_Array;\n   -- Write a function to find squares of individual elements in a list.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Square_Nums (Nums : Integer_Array) return Integer_Array", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_8_square_nums.py", "prompt_terminology": "verbatim", "tests": "\n   end Square_Nums;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Nums : Integer_Array) return Integer_Array renames Placeholder.Square_Nums;\n\nbegin\n   pragma Assert (Candidate ((1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) = (1, 4, 9, 16, 25, 36, 49, 64, 81, 100));\n   pragma Assert (Candidate ((10, 20, 30)) = (100, 400, 900));\n   pragma Assert (Candidate ((12, 15)) = (144, 225));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_90_len_log", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Len_Log (List1 : Unbounded_String_Array) return Integer;\n   -- Write a python function to find the length of the longest word.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Len_Log (List1 : Unbounded_String_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "verbatim", "tests": "\n   end Len_Log;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (List1 : Unbounded_String_Array) return Integer renames Placeholder.Len_Log;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"python\"), To_Unbounded_String (\"PHP\"), To_Unbounded_String (\"bigdata\"))) = 7);\n   pragma Assert (Candidate ((To_Unbounded_String (\"a\"), To_Unbounded_String (\"ab\"), To_Unbounded_String (\"abc\"))) = 3);\n   pragma Assert (Candidate ((To_Unbounded_String (\"small\"), To_Unbounded_String (\"big\"), To_Unbounded_String (\"tall\"))) = 5);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_91_find_substring", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Array is array (Integer range <>) of Unbounded_String;\n   function Find_Substring (Str1 : Unbounded_String_Array; Sub_Str : Unbounded_String) return Boolean;\n   -- Write a function to check if a string is present as a substring in a given list of string values.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Substring (Str1 : Unbounded_String_Array; Sub_Str : Unbounded_String) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Substring;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str1 : Unbounded_String_Array; Sub_Str : Unbounded_String) return Boolean renames Placeholder.Find_Substring;\n\nbegin\n   pragma Assert (Candidate ((To_Unbounded_String (\"red\"), To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), To_Unbounded_String (\"ack\")) = True);\n   pragma Assert (Candidate ((To_Unbounded_String (\"red\"), To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), To_Unbounded_String (\"abc\")) = False);\n   pragma Assert (Candidate ((To_Unbounded_String (\"red\"), To_Unbounded_String (\"black\"), To_Unbounded_String (\"white\"), To_Unbounded_String (\"green\"), To_Unbounded_String (\"orange\")), To_Unbounded_String (\"ange\")) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_92_is_undulating", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Is_Undulating (N : Integer) return Boolean;\n   -- Write a function to check whether the given number is undulating or not.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Is_Undulating (N : Integer) return Boolean", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "verbatim", "tests": "\n   end Is_Undulating;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Boolean renames Placeholder.Is_Undulating;\n\nbegin\n   pragma Assert (Candidate (1212121) = True);\n   pragma Assert (Candidate (1991) = False);\n   pragma Assert (Candidate (121) = True);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_93_power", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Power (A : Integer; B : Integer) return Integer;\n   -- Write a function to calculate the value of 'a' to the power 'b'.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Power (A : Integer; B : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_93_power.py", "prompt_terminology": "verbatim", "tests": "\n   end Power;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (A : Integer; B : Integer) return Integer renames Placeholder.Power;\n\nbegin\n   pragma Assert (Candidate (3, 4) = 81);\n   pragma Assert (Candidate (2, 3) = 8);\n   pragma Assert (Candidate (5, 5) = 3125);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_94_index_minimum", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Unbounded_String_Integer_Tuple_Array is array (Integer range <>) of Unbounded_String_Integer_Tuple;\n   type Unbounded_String_Integer_Tuple is record\n     Unbounded_String_1 : Unbounded_String;\n     Integer_2 : Integer;\n   end record;\n\n   function Index_Minimum (Test_List : Unbounded_String_Integer_Tuple_Array) return Unbounded_String;\n   -- Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Index_Minimum (Test_List : Unbounded_String_Integer_Tuple_Array) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py", "prompt_terminology": "verbatim", "tests": "\n   end Index_Minimum;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Test_List : Unbounded_String_Integer_Tuple_Array) return Unbounded_String renames Placeholder.Index_Minimum;\n\nbegin\n   pragma Assert (Candidate (((To_Unbounded_String (\"Rash\"), 143), (To_Unbounded_String (\"Manjeet\"), 200), (To_Unbounded_String (\"Varsha\"), 100))) = To_Unbounded_String (\"Varsha\"));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Yash\"), 185), (To_Unbounded_String (\"Dawood\"), 125), (To_Unbounded_String (\"Sanya\"), 175))) = To_Unbounded_String (\"Dawood\"));\n   pragma Assert (Candidate (((To_Unbounded_String (\"Sai\"), 345), (To_Unbounded_String (\"Salman\"), 145), (To_Unbounded_String (\"Ayesha\"), 96))) = To_Unbounded_String (\"Ayesha\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_95_Find_Min_Length", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   type Integer_Array is array (Integer range <>) of Integer;\n   type Integer_Array_Array is array (Integer range <>) of Integer_Array;\n   function Find_Min_Length (Lst : Integer_Array_Array) return Integer;\n   -- Write a python function to find the length of the smallest list in a list of lists.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Min_Length (Lst : Integer_Array_Array) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Min_Length;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Lst : Integer_Array_Array) return Integer renames Placeholder.Find_Min_Length;\n\nbegin\n   pragma Assert (Candidate (((0 => 1), (1, 2))) = 1);\n   pragma Assert (Candidate (((1, 2), (1, 2, 3), (1, 2, 3, 4))) = 2);\n   pragma Assert (Candidate (((3, 3, 3), (4, 4, 4, 4))) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_96_divisor", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Divisor (N : Integer) return Integer;\n   -- Write a python function to find the number of divisors of a given integer.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Divisor (N : Integer) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "verbatim", "tests": "\n   end Divisor;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Integer renames Placeholder.Divisor;\n\nbegin\n   pragma Assert (Candidate (15) = 4);\n   pragma Assert (Candidate (12) = 6);\n   pragma Assert (Candidate (9) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_99_decimal_to_binary", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Decimal_To_Binary (N : Integer) return Unbounded_String;\n   -- Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Decimal_To_Binary (N : Integer) return Unbounded_String", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "verbatim", "tests": "\n   end Decimal_To_Binary;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (N : Integer) return Unbounded_String renames Placeholder.Decimal_To_Binary;\n\nbegin\n   pragma Assert (Candidate (8) = To_Unbounded_String (\"1000\"));\n   pragma Assert (Candidate (18) = To_Unbounded_String (\"10010\"));\n   pragma Assert (Candidate (7) = To_Unbounded_String (\"111\"));\nend Main;", "stop_tokens": ["\n   end "]}
{"name": "mbpp_9_find_Rotations", "language": "adb", "prompt": "pragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage Placeholder is\n   function Find_Rotations (Str : Unbounded_String) return Integer;\n   -- Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\n\nend Placeholder;\n\npragma Ada_2012;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\npackage body Placeholder is\n   function Find_Rotations (Str : Unbounded_String) return Integer", "doctests": "keep", "original": "/home/walshe/projects/ai/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "verbatim", "tests": "\n   end Find_Rotations;\n\nend Placeholder;\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Placeholder; use Placeholder;\nprocedure Main is\n   function Candidate (Str : Unbounded_String) return Integer renames Placeholder.Find_Rotations;\n\nbegin\n   pragma Assert (Candidate (To_Unbounded_String (\"aaaa\")) = 1);\n   pragma Assert (Candidate (To_Unbounded_String (\"ab\")) = 2);\n   pragma Assert (Candidate (To_Unbounded_String (\"abc\")) = 3);\nend Main;", "stop_tokens": ["\n   end "]}
