{"name": "HumanEval_102_choose_num", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Choose_Num (X : Integer; Y : Integer) return Integer;\n   -- This function takes two positive numbers x and y and returns the\n   -- biggest even integer number that is in the range [x, y] inclusive. If \n   -- there's no such number, then the function should return -1.\n   -- For example:\n   -- choose_num(12, 15) = 14\n   -- choose_num(13, 12) = -1\n\n\n   function Choose_Num (X : Integer; Y : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_102_choose_num.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : Integer; Y : Integer) return Integer renames Choose_Num;\nbegin\n   Assert (Candidate (12, 15) = 14);\n   Assert (Candidate (13, 12) = -1);\n   Assert (Candidate (33, 12354) = 12354);\n   Assert (Candidate (5234, 5233) = -1);\n   Assert (Candidate (6, 29) = 28);\n   Assert (Candidate (27, 10) = -1);\n   Assert (Candidate (7, 7) = -1);\n   Assert (Candidate (546, 546) = 546);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_10_make_palindrome", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Make_Palindrome (S : String) return String;\n   -- Find the shortest palindrome that begins with a supplied string.\n   -- Algorithm idea is simple:\n   -- - Find the longest postfix of supplied string that is a palindrome.\n   -- - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n   -- >>> Make_Palindrome ()\n   -- >>> Make_Palindrome (cat)\n   -- catac\n   -- >>> Make_Palindrome (cata)\n   -- catac\n\n\n   function Make_Palindrome (S : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_10_make_palindrome.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return String renames Make_Palindrome;\nbegin\n   Assert (Candidate () = );\n   Assert (Candidate (x) = x);\n   Assert (Candidate (xyz) = xyzyx);\n   Assert (Candidate (xyx) = xyx);\n   Assert (Candidate (jerry) = jerryrrej);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_118_get_closest_vowel", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Get_Closest_Vowel (W : String) return String;\n   -- You are given a word. Your task is to find the closest vowel that stands between \n   -- two consonants from the right side of the word (case sensitive).\n   -- Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n   -- find any vowel met the above condition. \n   -- You may assume that the given string contains English letter only.\n   -- Example:\n   -- get_closest_vowel(\"yogurt\") ==> \"u\"\n   -- get_closest_vowel(\"FULL\") ==> \"U\"\n   -- get_closest_vowel(\"quick\") ==> \"\"\n   -- get_closest_vowel(\"ab\") ==> \"\"\n\n\n   function Get_Closest_Vowel (W : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_118_get_closest_vowel.py", "prompt_terminology": "reworded", "tests": "   function Candidate (W : String) return String renames Get_Closest_Vowel;\nbegin\n   Assert (Candidate (yogurt) = u);\n   Assert (Candidate (full) = u);\n   Assert (Candidate (easy) = );\n   Assert (Candidate (eAsy) = );\n   Assert (Candidate (ali) = );\n   Assert (Candidate (bad) = a);\n   Assert (Candidate (most) = o);\n   Assert (Candidate (ab) = );\n   Assert (Candidate (ba) = );\n   Assert (Candidate (quick) = );\n   Assert (Candidate (anime) = i);\n   Assert (Candidate (Asia) = );\n   Assert (Candidate (Above) = o);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_11_string_xor", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function String_Xor (A : String; B : String) return String;\n   -- Input are two strings a and b consisting only of 1s and 0s.\n   -- Perform binary XOR on these inputs and return result also as a string.\n   -- >>> String_Xor (010, 110)\n   -- 100\n\n\n   function String_Xor (A : String; B : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_11_string_xor.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : String; B : String) return String renames String_Xor;\nbegin\n   Assert (Candidate (111000, 101010) = 010010);\n   Assert (Candidate (1, 1) = 0);\n   Assert (Candidate (0101, 0000) = 0101);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_124_valid_date", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Valid_Date (D : String) return Boolean;\n   -- You have to write a function which validates a given date string and\n   -- returns True if the date is valid otherwise False.\n   -- The date is valid if all of the following rules are satisfied:\n   -- 1. The date string is not empty.\n   -- 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n   -- 3. The months should not be less than 1 or higher than 12.\n   -- 4. The date should be in the format: mm-dd-yyyy\n   -- for example: \n   -- valid_date('03-11-2000') => True\n   -- valid_date('15-01-2012') => False\n   -- valid_date('04-0-2040') => False\n   -- valid_date('06-04-2020') => True\n   -- valid_date('06/04/2020') => False\n\n\n   function Valid_Date (D : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_124_valid_date.py", "prompt_terminology": "reworded", "tests": "   function Candidate (D : String) return Boolean renames Valid_Date;\nbegin\n   Assert (Candidate (03-11-2000) = True);\n   Assert (Candidate (15-01-2012) = False);\n   Assert (Candidate (04-0-2040) = False);\n   Assert (Candidate (06-04-2020) = True);\n   Assert (Candidate (01-01-2007) = True);\n   Assert (Candidate (03-32-2011) = False);\n   Assert (Candidate () = False);\n   Assert (Candidate (04-31-3000) = False);\n   Assert (Candidate (06-06-2005) = True);\n   Assert (Candidate (21-31-2000) = False);\n   Assert (Candidate (04-12-2003) = True);\n   Assert (Candidate (04122003) = False);\n   Assert (Candidate (20030412) = False);\n   Assert (Candidate (2003-04) = False);\n   Assert (Candidate (2003-04-12) = False);\n   Assert (Candidate (04-2003) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_131_digits", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Digits (N : Integer) return Integer;\n   -- Given a positive integer n, return the product of the odd digits.\n   -- Return 0 if all digits are even.\n   -- For example:\n   -- digits(1)  == 1\n   -- digits(4)  == 0\n   -- digits(235) == 15\n\n\n   function Digits (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_131_digits.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Digits;\nbegin\n   Assert (Candidate (5) = 5);\n   Assert (Candidate (54) = 5);\n   Assert (Candidate (120) = 1);\n   Assert (Candidate (5014) = 5);\n   Assert (Candidate (98765) = 315);\n   Assert (Candidate (5576543) = 2625);\n   Assert (Candidate (2468) = 0);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_132_is_nested", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Nested (S : String) return Boolean;\n   -- Create a function that takes a string as input which contains only square brackets.\n   -- The function should return True if and only if there is a valid subsequence of brackets \n   -- where at least one bracket in the subsequence is nested.\n   -- is_nested('[[]]') \u279e True\n   -- is_nested('[]]]]]]][[[[[]') \u279e False\n   -- is_nested('[][]') \u279e False\n   -- is_nested('[]') \u279e False\n   -- is_nested('[[][]]') \u279e True\n   -- is_nested('[[]][[') \u279e True\n\n\n   function Is_Nested (S : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_132_is_nested.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Boolean renames Is_Nested;\nbegin\n   Assert (Candidate ([[]]) = True);\n   Assert (Candidate ([]]]]]]][[[[[]) = False);\n   Assert (Candidate ([][]) = False);\n   Assert (Candidate ([]) = False);\n   Assert (Candidate ([[[[]]]]) = True);\n   Assert (Candidate ([]]]]]]]]]]) = False);\n   Assert (Candidate ([][][[]]) = True);\n   Assert (Candidate ([[]) = False);\n   Assert (Candidate ([]]) = False);\n   Assert (Candidate ([[]][[) = True);\n   Assert (Candidate ([[][]]) = True);\n   Assert (Candidate () = False);\n   Assert (Candidate ([[[[[[[[) = False);\n   Assert (Candidate (]]]]]]]]) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_134_check_if_last_char_is_a_letter", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Check_If_Last_Char_Is_A_Letter (T : String) return Boolean;\n   -- Create a function that returns True if the last character\n   -- of a given string is an alphabetical character and is not\n   -- a part of a word, and False otherwise.\n   -- Note: \"word\" is a group of characters separated by space.\n   -- Examples:\n   -- check_if_last_char_is_a_letter(\"apple pie\") \u279e False\n   -- check_if_last_char_is_a_letter(\"apple pi e\") \u279e True\n   -- check_if_last_char_is_a_letter(\"apple pi e \") \u279e False\n   -- check_if_last_char_is_a_letter(\"\") \u279e False\n\n\n   function Check_If_Last_Char_Is_A_Letter (T : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_134_check_if_last_char_is_a_letter.py", "prompt_terminology": "reworded", "tests": "   function Candidate (T : String) return Boolean renames Check_If_Last_Char_Is_A_Letter;\nbegin\n   Assert (Candidate (apple) = False);\n   Assert (Candidate (apple pi e) = True);\n   Assert (Candidate (eeeee) = False);\n   Assert (Candidate (A) = True);\n   Assert (Candidate (Pumpkin pie ) = False);\n   Assert (Candidate (Pumpkin pie 1) = False);\n   Assert (Candidate () = False);\n   Assert (Candidate (eeeee e ) = False);\n   Assert (Candidate (apple pie) = False);\n   Assert (Candidate (apple pi e ) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_138_is_equal_to_sum_even", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Equal_To_Sum_Even (N : Integer) return Boolean;\n   -- Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n   -- Example\n   -- is_equal_to_sum_even(4) == False\n   -- is_equal_to_sum_even(6) == False\n   -- is_equal_to_sum_even(8) == True\n\n\n   function Is_Equal_To_Sum_Even (N : Integer) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_138_is_equal_to_sum_even.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Boolean renames Is_Equal_To_Sum_Even;\nbegin\n   Assert (Candidate (4) = False);\n   Assert (Candidate (6) = False);\n   Assert (Candidate (8) = True);\n   Assert (Candidate (10) = True);\n   Assert (Candidate (11) = False);\n   Assert (Candidate (12) = True);\n   Assert (Candidate (13) = False);\n   Assert (Candidate (16) = True);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_139_special_factorial", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Special_Factorial (N : Integer) return Integer;\n   -- The Brazilian factorial is defined as:\n   -- brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n   -- where n > 0\n   -- For example:\n   -- >>> Special_Factorial (4)\n   -- 288\n   -- The function will receive an integer as input and should return the special\n   -- factorial of this integer.\n\n\n   function Special_Factorial (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_139_special_factorial.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Special_Factorial;\nbegin\n   Assert (Candidate (4) = 288);\n   Assert (Candidate (5) = 34560);\n   Assert (Candidate (7) = 125411328000);\n   Assert (Candidate (1) = 1);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_13_greatest_common_divisor", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Greatest_Common_Divisor (A : Integer; B : Integer) return Integer;\n   -- Return a greatest common divisor of two integers a and b\n   -- >>> Greatest_Common_Divisor (3, 5)\n   -- 1\n   -- >>> Greatest_Common_Divisor (25, 15)\n   -- 5\n\n\n   function Greatest_Common_Divisor (A : Integer; B : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_13_greatest_common_divisor.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer; B : Integer) return Integer renames Greatest_Common_Divisor;\nbegin\n   Assert (Candidate (3, 7) = 1);\n   Assert (Candidate (10, 15) = 5);\n   Assert (Candidate (49, 14) = 7);\n   Assert (Candidate (144, 60) = 12);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_140_fix_spaces", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Fix_Spaces (T : String) return String;\n   -- Given a string text, replace all spaces in it with underscores, \n   -- and if a string has more than 2 consecutive spaces, \n   -- then replace all consecutive spaces with - \n   -- fix_spaces(\"Example\") == \"Example\"\n   -- fix_spaces(\"Example 1\") == \"Example_1\"\n   -- fix_spaces(\" Example 2\") == \"_Example_2\"\n   -- fix_spaces(\" Example   3\") == \"_Example-3\"\n\n\n   function Fix_Spaces (T : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_140_fix_spaces.py", "prompt_terminology": "reworded", "tests": "   function Candidate (T : String) return String renames Fix_Spaces;\nbegin\n   Assert (Candidate (Example) = Example);\n   Assert (Candidate (Mudasir Hanif ) = Mudasir_Hanif_);\n   Assert (Candidate (Yellow Yellow  Dirty  Fellow) = Yellow_Yellow__Dirty__Fellow);\n   Assert (Candidate (Exa   mple) = Exa-mple);\n   Assert (Candidate (   Exa 1 2 2 mple) = -Exa_1_2_2_mple);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_141_file_name_check", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function File_Name_Check (F : String) return String;\n   -- Create a function which takes a string representing a file's name, and returns\n   -- 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n   -- A file's name is considered to be valid if and only if all the following conditions \n   -- are met:\n   -- - There should not be more than three digits ('0'-'9') in the file's name.\n   -- - The file's name contains exactly one dot '.'\n   -- - The substring before the dot should not be empty, and it starts with a letter from \n   -- the latin alphapet ('a'-'z' and 'A'-'Z').\n   -- - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n   -- Examples:\n   -- file_name_check(\"example.txt\") # => 'Yes'\n   -- file_name_check(\"1example.dll\") # => 'No' (the name should start with a latin alphapet letter)\n\n\n   function File_Name_Check (F : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_141_file_name_check.py", "prompt_terminology": "reworded", "tests": "   function Candidate (F : String) return String renames File_Name_Check;\nbegin\n   Assert (Candidate (example.txt) = Yes);\n   Assert (Candidate (1example.dll) = No);\n   Assert (Candidate (s1sdf3.asd) = No);\n   Assert (Candidate (K.dll) = Yes);\n   Assert (Candidate (MY16FILE3.exe) = Yes);\n   Assert (Candidate (His12FILE94.exe) = No);\n   Assert (Candidate (_Y.txt) = No);\n   Assert (Candidate (?aREYA.exe) = No);\n   Assert (Candidate (/this_is_valid.dll) = No);\n   Assert (Candidate (this_is_valid.wow) = No);\n   Assert (Candidate (this_is_valid.txt) = Yes);\n   Assert (Candidate (this_is_valid.txtexe) = No);\n   Assert (Candidate (#this2_i4s_5valid.ten) = No);\n   Assert (Candidate (@this1_is6_valid.exe) = No);\n   Assert (Candidate (this_is_12valid.6exe4.txt) = No);\n   Assert (Candidate (all.exe.txt) = No);\n   Assert (Candidate (I563_No.exe) = Yes);\n   Assert (Candidate (Is3youfault.txt) = Yes);\n   Assert (Candidate (no_one#knows.dll) = Yes);\n   Assert (Candidate (1I563_Yes3.exe) = No);\n   Assert (Candidate (I563_Yes3.txtt) = No);\n   Assert (Candidate (final..txt) = No);\n   Assert (Candidate (final132) = No);\n   Assert (Candidate (_f4indsartal132.) = No);\n   Assert (Candidate (.txt) = No);\n   Assert (Candidate (s.) = No);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_143_words_in_sentence", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Words_In_Sentence (S : String) return String;\n   -- You are given a string representing a sentence,\n   -- the sentence contains some words separated by a space,\n   -- and you have to return a string that contains the words from the original sentence,\n   -- whose lengths are prime numbers,\n   -- the order of the words in the new string should be the same as the original one.\n   -- Example 1:\n   -- Input: sentence = \"This is a test\"\n   -- Output: \"is\"\n   -- Example 2:\n   -- Input: sentence = \"lets go for swimming\"\n   -- Output: \"go for\"\n   -- Constraints:\n   -- * 1 <= len(sentence) <= 100\n   -- * sentence contains only letters\n\n\n   function Words_In_Sentence (S : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_143_words_in_sentence.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return String renames Words_In_Sentence;\nbegin\n   Assert (Candidate (This is a test) = is);\n   Assert (Candidate (lets go for swimming) = go for);\n   Assert (Candidate (there is no place available here) = there is no place);\n   Assert (Candidate (Hi I am Hussein) = Hi am Hussein);\n   Assert (Candidate (go for it) = go for it);\n   Assert (Candidate (here) = );\n   Assert (Candidate (here is) = is);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_144_simplify", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Simplify (X : String; N : String) return Boolean;\n   -- Your task is to implement a function that will simplify the expression\n   -- x * n. The function returns True if x * n evaluates to a whole number and False\n   -- otherwise. Both x and n, are string representation of a fraction, and have the following format,\n   -- <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n   -- You can assume that x, and n are valid fractions, and do not have zero as denominator.\n   -- simplify(\"1/5\", \"5/1\") = True\n   -- simplify(\"1/6\", \"2/1\") = False\n   -- simplify(\"7/10\", \"10/2\") = False\n\n\n   function Simplify (X : String; N : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_144_simplify.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : String; N : String) return Boolean renames Simplify;\nbegin\n   Assert (Candidate (1/5, 5/1) = True);\n   Assert (Candidate (1/6, 2/1) = False);\n   Assert (Candidate (5/1, 3/1) = True);\n   Assert (Candidate (7/10, 10/2) = False);\n   Assert (Candidate (2/10, 50/10) = True);\n   Assert (Candidate (7/2, 4/2) = True);\n   Assert (Candidate (11/6, 6/1) = True);\n   Assert (Candidate (2/3, 5/2) = False);\n   Assert (Candidate (5/2, 3/5) = False);\n   Assert (Candidate (2/4, 8/4) = True);\n   Assert (Candidate (2/4, 4/2) = True);\n   Assert (Candidate (1/5, 5/1) = True);\n   Assert (Candidate (1/5, 1/5) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_147_get_max_triples", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Get_Max_Triples (N : Integer) return Integer;\n   -- You are given a positive integer n. You have to create an integer array a of length n.\n   -- For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n   -- Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n   -- and a[i] + a[j] + a[k] is a multiple of 3.\n   -- Example :\n   -- Input: n = 5\n   -- Output: 1\n   -- Explanation: \n   -- a = [1, 3, 7, 13, 21]\n   -- The only valid triple is (1, 7, 13).\n\n\n   function Get_Max_Triples (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_147_get_max_triples.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Get_Max_Triples;\nbegin\n   Assert (Candidate (5) = 1);\n   Assert (Candidate (6) = 4);\n   Assert (Candidate (10) = 36);\n   Assert (Candidate (100) = 53361);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_150_x_or_y", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function X_Or_Y (N : Integer; X : Integer; Y : Integer) return Integer;\n   -- A simple program which should return the value of x if n is \n   -- a prime number and should return the value of y otherwise.\n   -- Examples:\n   -- for x_or_y(7, 34, 12) == 34\n   -- for x_or_y(15, 8, 5) == 5\n\n\n   function X_Or_Y (N : Integer; X : Integer; Y : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_150_x_or_y.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer; X : Integer; Y : Integer) return Integer renames X_Or_Y;\nbegin\n   Assert (Candidate (7, 34, 12) = 34);\n   Assert (Candidate (15, 8, 5) = 5);\n   Assert (Candidate (3, 33, 5212) = 33);\n   Assert (Candidate (1259, 3, 52) = 3);\n   Assert (Candidate (7919, -1, 12) = -1);\n   Assert (Candidate (3609, 1245, 583) = 583);\n   Assert (Candidate (91, 56, 129) = 129);\n   Assert (Candidate (6, 34, 1234) = 1234);\n   Assert (Candidate (1, 2, 0) = 0);\n   Assert (Candidate (2, 2, 0) = 2);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_154_cycpattern_check", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Cycpattern_Check (A : String; B : String) return Boolean;\n   -- You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n   -- cycpattern_check(\"abcd\",\"abd\") => False\n   -- cycpattern_check(\"hello\",\"ell\") => True\n   -- cycpattern_check(\"whassup\",\"psus\") => False\n   -- cycpattern_check(\"abab\",\"baa\") => True\n   -- cycpattern_check(\"efef\",\"eeff\") => False\n   -- cycpattern_check(\"himenss\",\"simen\") => True\n\n\n   function Cycpattern_Check (A : String; B : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_154_cycpattern_check.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : String; B : String) return Boolean renames Cycpattern_Check;\nbegin\n   Assert (Candidate (xyzw, xyw) = False);\n   Assert (Candidate (yello, ell) = True);\n   Assert (Candidate (whattup, ptut) = False);\n   Assert (Candidate (efef, fee) = True);\n   Assert (Candidate (abab, aabb) = False);\n   Assert (Candidate (winemtt, tinem) = True);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_157_right_angle_triangle", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Right_Angle_Triangle (A : Integer; B : Integer; C : Integer) return Boolean;\n   -- Given the lengths of the three sides of a triangle. Return True if the three\n   -- sides form a right-angled triangle, False otherwise.\n   -- A right-angled triangle is a triangle in which one angle is right angle or \n   -- 90 degree.\n   -- Example:\n   -- right_angle_triangle(3, 4, 5) == True\n   -- right_angle_triangle(1, 2, 3) == False\n\n\n   function Right_Angle_Triangle (A : Integer; B : Integer; C : Integer) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_157_right_angle_triangle.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer; B : Integer; C : Integer) return Boolean renames Right_Angle_Triangle;\nbegin\n   Assert (Candidate (3, 4, 5) = True);\n   Assert (Candidate (1, 2, 3) = False);\n   Assert (Candidate (10, 6, 8) = True);\n   Assert (Candidate (2, 2, 2) = False);\n   Assert (Candidate (7, 24, 25) = True);\n   Assert (Candidate (10, 5, 7) = False);\n   Assert (Candidate (5, 12, 13) = True);\n   Assert (Candidate (15, 8, 17) = True);\n   Assert (Candidate (48, 55, 73) = True);\n   Assert (Candidate (1, 1, 1) = False);\n   Assert (Candidate (2, 2, 10) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_15_string_sequence", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function String_Sequence (N : Integer) return String;\n   -- Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n   -- >>> String_Sequence (0)\n   -- 0\n   -- >>> String_Sequence (5)\n   -- 0 1 2 3 4 5\n\n\n   function String_Sequence (N : Integer) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_15_string_sequence.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return String renames String_Sequence;\nbegin\n   Assert (Candidate (0) = 0);\n   Assert (Candidate (3) = 0 1 2 3);\n   Assert (Candidate (10) = 0 1 2 3 4 5 6 7 8 9 10);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_161_solve", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Solve (S : String) return String;\n   -- You are given a string s.\n   -- if s[i] is a letter, reverse its case from lower to upper or vise versa, \n   -- otherwise keep it as it is.\n   -- If the string contains no letters, reverse the string.\n   -- The function should return the resulted string.\n   -- Examples\n   -- solve(\"1234\") = \"4321\"\n   -- solve(\"ab\") = \"AB\"\n   -- solve(\"#a@C\") = \"#A@c\"\n\n\n   function Solve (S : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_161_solve.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return String renames Solve;\nbegin\n   Assert (Candidate (AsDf) = aSdF);\n   Assert (Candidate (1234) = 4321);\n   Assert (Candidate (ab) = AB);\n   Assert (Candidate (#a@C) = #A@c);\n   Assert (Candidate (#AsdfW^45) = #aSDFw^45);\n   Assert (Candidate (#6@2) = 2@6#);\n   Assert (Candidate (#$a^D) = #$A^d);\n   Assert (Candidate (#ccc) = #CCC);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_16_count_distinct_characters", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Count_Distinct_Characters (S : String) return Integer;\n   -- Given a string, find out how many distinct characters (regardless of case) does it consist of\n   -- >>> Count_Distinct_Characters (xyzXYZ)\n   -- 3\n   -- >>> Count_Distinct_Characters (Jerry)\n   -- 4\n\n\n   function Count_Distinct_Characters (S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_16_count_distinct_characters.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Integer renames Count_Distinct_Characters;\nbegin\n   Assert (Candidate () = 0);\n   Assert (Candidate (abcde) = 5);\n   Assert (Candidate (abcdecadeCADE) = 5);\n   Assert (Candidate (aaaaAAAAaaaa) = 1);\n   Assert (Candidate (Jerry jERRY JeRRRY) = 5);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_18_how_many_times", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function How_Many_Times (S : String; S : String) return Integer;\n   -- Find how many times a given substring can be found in the original string. Count overlaping cases.\n   -- >>> How_Many_Times (, a)\n   -- 0\n   -- >>> How_Many_Times (aaa, a)\n   -- 3\n   -- >>> How_Many_Times (aaaa, aa)\n   -- 3\n\n\n   function How_Many_Times (S : String; S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_18_how_many_times.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String; S : String) return Integer renames How_Many_Times;\nbegin\n   Assert (Candidate (, x) = 0);\n   Assert (Candidate (xyxyxyx, x) = 4);\n   Assert (Candidate (cacacacac, cac) = 4);\n   Assert (Candidate (john doe, john) = 1);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_19_sort_numbers", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Sort_Numbers (N : String) return String;\n   -- Input is a space-delimited string of numberals from 'zero' to 'nine'.\n   -- Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n   -- Return the string with numbers sorted from smallest to largest\n   -- >>> Sort_Numbers (three one five)\n   -- one three five\n\n\n   function Sort_Numbers (N : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_19_sort_numbers.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : String) return String renames Sort_Numbers;\nbegin\n   Assert (Candidate () = );\n   Assert (Candidate (three) = three);\n   Assert (Candidate (three five nine) = three five nine);\n   Assert (Candidate (five zero four seven nine eight) = zero four five seven eight nine);\n   Assert (Candidate (six five four three two one zero) = zero one two three four five six);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_23_strlen", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Strlen (S : String) return Integer;\n   -- Return length of given string\n   -- >>> Strlen ()\n   -- 0\n   -- >>> Strlen (abc)\n   -- 3\n\n\n   function Strlen (S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_23_strlen.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Integer renames Strlen;\nbegin\n   Assert (Candidate () = 0);\n   Assert (Candidate (x) = 1);\n   Assert (Candidate (asdasnakj) = 9);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_24_largest_divisor", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Largest_Divisor (N : Integer) return Integer;\n   -- For a given number n, find the largest number that divides n evenly, smaller than n\n   -- >>> Largest_Divisor (15)\n   -- 5\n\n\n   function Largest_Divisor (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_24_largest_divisor.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Largest_Divisor;\nbegin\n   Assert (Candidate (3) = 1);\n   Assert (Candidate (7) = 1);\n   Assert (Candidate (10) = 5);\n   Assert (Candidate (100) = 50);\n   Assert (Candidate (49) = 7);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_27_flip_case", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Flip_Case (S : String) return String;\n   -- For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n   -- >>> Flip_Case (Hello)\n   -- hELLO\n\n\n   function Flip_Case (S : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_27_flip_case.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return String renames Flip_Case;\nbegin\n   Assert (Candidate () = );\n   Assert (Candidate (Hello!) = hELLO!);\n   Assert (Candidate (These violent delights have violent ends) = tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_2_truncate_number", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Truncate_Number (N : Float) return Float;\n   -- Given a positive floating point number, it can be decomposed into\n   -- and integer part (largest integer smaller than given number) and decimals\n   -- (leftover part always smaller than 1).\n   -- Return the decimal part of the number.\n   -- >>> Truncate_Number (3.5)\n   -- 0.5\n\n\n   function Truncate_Number (N : Float) return Float", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_2_truncate_number.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Float) return Float renames Truncate_Number;\nbegin\n   Assert (Candidate (3.5) = 0.5);\n   Assert (Candidate (1.25) = 0.25);\n   Assert (Candidate (123.0) = 0.0);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_31_is_prime", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Prime (N : Integer) return Boolean;\n   -- Return true if a given number is prime, and false otherwise.\n   -- >>> Is_Prime (6)\n   -- False\n   -- >>> Is_Prime (101)\n   -- True\n   -- >>> Is_Prime (11)\n   -- True\n   -- >>> Is_Prime (13441)\n   -- True\n   -- >>> Is_Prime (61)\n   -- True\n   -- >>> Is_Prime (4)\n   -- False\n   -- >>> Is_Prime (1)\n   -- False\n\n\n   function Is_Prime (N : Integer) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_31_is_prime.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Boolean renames Is_Prime;\nbegin\n   Assert (Candidate (6) = False);\n   Assert (Candidate (101) = True);\n   Assert (Candidate (11) = True);\n   Assert (Candidate (13441) = True);\n   Assert (Candidate (61) = True);\n   Assert (Candidate (4) = False);\n   Assert (Candidate (1) = False);\n   Assert (Candidate (5) = True);\n   Assert (Candidate (11) = True);\n   Assert (Candidate (17) = True);\n   Assert (Candidate (85) = False);\n   Assert (Candidate (77) = False);\n   Assert (Candidate (255379) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_36_fizz_buzz", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Fizz_Buzz (N : Integer) return Integer;\n   -- Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n   -- >>> Fizz_Buzz (50)\n   -- 0\n   -- >>> Fizz_Buzz (78)\n   -- 2\n   -- >>> Fizz_Buzz (79)\n   -- 3\n\n\n   function Fizz_Buzz (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_36_fizz_buzz.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Fizz_Buzz;\nbegin\n   Assert (Candidate (50) = 0);\n   Assert (Candidate (78) = 2);\n   Assert (Candidate (79) = 3);\n   Assert (Candidate (100) = 3);\n   Assert (Candidate (200) = 6);\n   Assert (Candidate (4000) = 192);\n   Assert (Candidate (10000) = 639);\n   Assert (Candidate (100000) = 8026);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_39_prime_fib", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Prime_Fib (N : Integer) return Integer;\n   -- prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n   -- >>> Prime_Fib (1)\n   -- 2\n   -- >>> Prime_Fib (2)\n   -- 3\n   -- >>> Prime_Fib (3)\n   -- 5\n   -- >>> Prime_Fib (4)\n   -- 13\n   -- >>> Prime_Fib (5)\n   -- 89\n\n\n   function Prime_Fib (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_39_prime_fib.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Prime_Fib;\nbegin\n   Assert (Candidate (1) = 2);\n   Assert (Candidate (2) = 3);\n   Assert (Candidate (3) = 5);\n   Assert (Candidate (4) = 13);\n   Assert (Candidate (5) = 89);\n   Assert (Candidate (6) = 233);\n   Assert (Candidate (7) = 1597);\n   Assert (Candidate (8) = 28657);\n   Assert (Candidate (9) = 514229);\n   Assert (Candidate (10) = 433494437);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_41_car_race_collision", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Car_Race_Collision (N : Integer) return Integer;\n   -- Imagine a road that's a perfectly straight infinitely long line.\n   -- n cars are driving left to right;  simultaneously, a different set of n cars\n   -- are driving right to left.   The two sets of cars start out being very far from\n   -- each other.  All cars move in the same speed.  Two cars are said to collide\n   -- when a car that's moving left to right hits a car that's moving right to left.\n   -- However, the cars are infinitely sturdy and strong; as a result, they continue moving\n   -- in their trajectory as if they did not collide.\n   -- This function outputs the number of such collisions.\n\n\n   function Car_Race_Collision (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_41_car_race_collision.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Car_Race_Collision;\nbegin\n   Assert (Candidate (2) = 4);\n   Assert (Candidate (3) = 9);\n   Assert (Candidate (4) = 16);\n   Assert (Candidate (8) = 64);\n   Assert (Candidate (10) = 100);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_44_change_base", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Change_Base (X : Integer; B : Integer) return String;\n   -- Change numerical base of input number x to base.\n   -- return string representation after the conversion.\n   -- base numbers are less than 10.\n   -- >>> Change_Base (8, 3)\n   -- 22\n   -- >>> Change_Base (8, 2)\n   -- 1000\n   -- >>> Change_Base (7, 2)\n   -- 111\n\n\n   function Change_Base (X : Integer; B : Integer) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_44_change_base.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : Integer; B : Integer) return String renames Change_Base;\nbegin\n   Assert (Candidate (8, 3) = 22);\n   Assert (Candidate (9, 3) = 100);\n   Assert (Candidate (234, 2) = 11101010);\n   Assert (Candidate (16, 2) = 10000);\n   Assert (Candidate (8, 2) = 1000);\n   Assert (Candidate (7, 2) = 111);\n   Assert (Candidate (2, 3) = 2);\n   Assert (Candidate (3, 4) = 3);\n   Assert (Candidate (4, 5) = 4);\n   Assert (Candidate (5, 6) = 5);\n   Assert (Candidate (6, 7) = 6);\n   Assert (Candidate (7, 8) = 7);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_45_triangle_area", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Triangle_Area (A : Integer; H : Integer) return Float;\n   -- Given length of a side and high return area for a triangle.\n   -- >>> Triangle_Area (5, 3)\n   -- 7.5\n\n\n   function Triangle_Area (A : Integer; H : Integer) return Float", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_45_triangle_area.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer; H : Integer) return Float renames Triangle_Area;\nbegin\n   Assert (Candidate (5, 3) = 7.5);\n   Assert (Candidate (2, 2) = 2.0);\n   Assert (Candidate (10, 8) = 40.0);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_46_fib4", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Fib4 (N : Integer) return Integer;\n   -- The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n   -- fib4(0) -> 0\n   -- fib4(1) -> 0\n   -- fib4(2) -> 2\n   -- fib4(3) -> 0\n   -- fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n   -- Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n   -- >>> Fib4 (5)\n   -- 4\n   -- >>> Fib4 (6)\n   -- 8\n   -- >>> Fib4 (7)\n   -- 14\n\n\n   function Fib4 (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_46_fib4.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Fib4;\nbegin\n   Assert (Candidate (5) = 4);\n   Assert (Candidate (8) = 28);\n   Assert (Candidate (10) = 104);\n   Assert (Candidate (12) = 386);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_48_is_palindrome", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Palindrome (T : String) return Boolean;\n   -- Checks if given string is a palindrome\n   -- >>> Is_Palindrome ()\n   -- True\n   -- >>> Is_Palindrome (aba)\n   -- True\n   -- >>> Is_Palindrome (aaaaa)\n   -- True\n   -- >>> Is_Palindrome (zbcd)\n   -- False\n\n\n   function Is_Palindrome (T : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_48_is_palindrome.py", "prompt_terminology": "reworded", "tests": "   function Candidate (T : String) return Boolean renames Is_Palindrome;\nbegin\n   Assert (Candidate () = True);\n   Assert (Candidate (aba) = True);\n   Assert (Candidate (aaaaa) = True);\n   Assert (Candidate (zbcd) = False);\n   Assert (Candidate (xywyx) = True);\n   Assert (Candidate (xywyz) = False);\n   Assert (Candidate (xywzx) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_49_modp", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Modp (N : Integer; P : Integer) return Integer;\n   -- Return 2^n modulo p (be aware of numerics).\n   -- >>> Modp (3, 5)\n   -- 3\n   -- >>> Modp (1101, 101)\n   -- 2\n   -- >>> Modp (0, 101)\n   -- 1\n   -- >>> Modp (3, 11)\n   -- 8\n   -- >>> Modp (100, 101)\n   -- 1\n\n\n   function Modp (N : Integer; P : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_49_modp.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer; P : Integer) return Integer renames Modp;\nbegin\n   Assert (Candidate (3, 5) = 3);\n   Assert (Candidate (1101, 101) = 2);\n   Assert (Candidate (0, 101) = 1);\n   Assert (Candidate (3, 11) = 8);\n   Assert (Candidate (100, 101) = 1);\n   Assert (Candidate (30, 5) = 4);\n   Assert (Candidate (31, 5) = 3);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_51_remove_vowels", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Remove_Vowels (T : String) return String;\n   -- remove_vowels is a function that takes string and returns string without vowels.\n   -- >>> Remove_Vowels ()\n   -- >>> Remove_Vowels (abcdef)\n   -- bcdf\n   -- >>> Remove_Vowels (aaaaa)\n   -- >>> Remove_Vowels (aaBAA)\n   -- B\n   -- >>> Remove_Vowels (zbcd)\n   -- zbcd\n\n\n   function Remove_Vowels (T : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_51_remove_vowels.py", "prompt_terminology": "reworded", "tests": "   function Candidate (T : String) return String renames Remove_Vowels;\nbegin\n   Assert (Candidate () = );\n   Assert (Candidate (abcdef\nghijklm) = bcdf\nghjklm);\n   Assert (Candidate (fedcba) = fdcb);\n   Assert (Candidate (eeeee) = );\n   Assert (Candidate (acBAA) = cB);\n   Assert (Candidate (EcBOO) = cB);\n   Assert (Candidate (ybcd) = ybcd);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_53_add", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Add (X : Integer; Y : Integer) return Integer;\n   -- Add two numbers x and y\n   -- >>> Add (2, 3)\n   -- 5\n   -- >>> Add (5, 7)\n   -- 12\n\n\n   function Add (X : Integer; Y : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_53_add.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : Integer; Y : Integer) return Integer renames Add;\nbegin\n   Assert (Candidate (0, 1) = 1);\n   Assert (Candidate (1, 0) = 1);\n   Assert (Candidate (2, 3) = 5);\n   Assert (Candidate (5, 7) = 12);\n   Assert (Candidate (7, 5) = 12);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_54_same_chars", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Same_Chars (S : String; S : String) return Boolean;\n   -- Check if two words have the same characters.\n   -- >>> Same_Chars (eabcdzzzz, dddzzzzzzzddeddabc)\n   -- True\n   -- >>> Same_Chars (abcd, dddddddabc)\n   -- True\n   -- >>> Same_Chars (dddddddabc, abcd)\n   -- True\n   -- >>> Same_Chars (eabcd, dddddddabc)\n   -- False\n   -- >>> Same_Chars (abcd, dddddddabce)\n   -- False\n   -- >>> Same_Chars (eabcdzzzz, dddzzzzzzzddddabc)\n   -- False\n\n\n   function Same_Chars (S : String; S : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_54_same_chars.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String; S : String) return Boolean renames Same_Chars;\nbegin\n   Assert (Candidate (eabcdzzzz, dddzzzzzzzddeddabc) = True);\n   Assert (Candidate (abcd, dddddddabc) = True);\n   Assert (Candidate (dddddddabc, abcd) = True);\n   Assert (Candidate (eabcd, dddddddabc) = False);\n   Assert (Candidate (abcd, dddddddabcf) = False);\n   Assert (Candidate (eabcdzzzz, dddzzzzzzzddddabc) = False);\n   Assert (Candidate (aabb, aaccc) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_55_fib", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Fib (N : Integer) return Integer;\n   -- Return n-th Fibonacci number.\n   -- >>> Fib (10)\n   -- 55\n   -- >>> Fib (1)\n   -- 1\n   -- >>> Fib (8)\n   -- 21\n\n\n   function Fib (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_55_fib.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Fib;\nbegin\n   Assert (Candidate (10) = 55);\n   Assert (Candidate (1) = 1);\n   Assert (Candidate (8) = 21);\n   Assert (Candidate (11) = 89);\n   Assert (Candidate (12) = 144);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_56_correct_bracketing", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Correct_Bracketing (B : String) return Boolean;\n   -- brackets is a string of \"<\" and \">\".\n   -- return True if every opening bracket has a corresponding closing bracket.\n   -- >>> Correct_Bracketing (<)\n   -- False\n   -- >>> Correct_Bracketing (<>)\n   -- True\n   -- >>> Correct_Bracketing (<<><>>)\n   -- True\n   -- >>> Correct_Bracketing (><<>)\n   -- False\n\n\n   function Correct_Bracketing (B : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_56_correct_bracketing.py", "prompt_terminology": "reworded", "tests": "   function Candidate (B : String) return Boolean renames Correct_Bracketing;\nbegin\n   Assert (Candidate (<>) = True);\n   Assert (Candidate (<<><>>) = True);\n   Assert (Candidate (<><><<><>><>) = True);\n   Assert (Candidate (<><><<<><><>><>><<><><<>>>) = True);\n   Assert (Candidate (<<<><>>>>) = False);\n   Assert (Candidate (><<>) = False);\n   Assert (Candidate (<) = False);\n   Assert (Candidate (<<<<) = False);\n   Assert (Candidate (>) = False);\n   Assert (Candidate (<<>) = False);\n   Assert (Candidate (<><><<><>><>><<>) = False);\n   Assert (Candidate (<><><<><>><>>><>) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_59_largest_prime_factor", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Largest_Prime_Factor (N : Integer) return Integer;\n   -- Return the largest prime factor of n. Assume n > 1 and is not a prime.\n   -- >>> Largest_Prime_Factor (13195)\n   -- 29\n   -- >>> Largest_Prime_Factor (2048)\n   -- 2\n\n\n   function Largest_Prime_Factor (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_59_largest_prime_factor.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Largest_Prime_Factor;\nbegin\n   Assert (Candidate (15) = 5);\n   Assert (Candidate (27) = 3);\n   Assert (Candidate (63) = 7);\n   Assert (Candidate (330) = 11);\n   Assert (Candidate (13195) = 29);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_60_sum_to_n", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Sum_To_N (N : Integer) return Integer;\n   -- sum_to_n is a function that sums numbers from 1 to n.\n   -- >>> Sum_To_N (30)\n   -- 465\n   -- >>> Sum_To_N (100)\n   -- 5050\n   -- >>> Sum_To_N (5)\n   -- 15\n   -- >>> Sum_To_N (10)\n   -- 55\n   -- >>> Sum_To_N (1)\n   -- 1\n\n\n   function Sum_To_N (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_60_sum_to_n.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Sum_To_N;\nbegin\n   Assert (Candidate (1) = 1);\n   Assert (Candidate (6) = 21);\n   Assert (Candidate (11) = 66);\n   Assert (Candidate (30) = 465);\n   Assert (Candidate (100) = 5050);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_61_correct_bracketing", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Correct_Bracketing (B : String) return Boolean;\n   -- brackets is a string of \"(\" and \")\".\n   -- return True if every opening bracket has a corresponding closing bracket.\n   -- >>> Correct_Bracketing (()\n   -- False\n   -- >>> Correct_Bracketing (())\n   -- True\n   -- >>> Correct_Bracketing ((()()))\n   -- True\n   -- >>> Correct_Bracketing ()(())\n   -- False\n\n\n   function Correct_Bracketing (B : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_61_correct_bracketing.py", "prompt_terminology": "reworded", "tests": "   function Candidate (B : String) return Boolean renames Correct_Bracketing;\nbegin\n   Assert (Candidate (()) = True);\n   Assert (Candidate ((()())) = True);\n   Assert (Candidate (()()(()())()) = True);\n   Assert (Candidate (()()((()()())())(()()(()))) = True);\n   Assert (Candidate (((()())))) = False);\n   Assert (Candidate ()(()) = False);\n   Assert (Candidate (() = False);\n   Assert (Candidate ((((() = False);\n   Assert (Candidate ()) = False);\n   Assert (Candidate ((()) = False);\n   Assert (Candidate (()()(()())())(()) = False);\n   Assert (Candidate (()()(()())()))()) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_63_fibfib", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Fibfib (N : Integer) return Integer;\n   -- The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n   -- fibfib(0) == 0\n   -- fibfib(1) == 0\n   -- fibfib(2) == 1\n   -- fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n   -- Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n   -- >>> Fibfib (1)\n   -- 0\n   -- >>> Fibfib (5)\n   -- 4\n   -- >>> Fibfib (8)\n   -- 24\n\n\n   function Fibfib (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_63_fibfib.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Fibfib;\nbegin\n   Assert (Candidate (2) = 1);\n   Assert (Candidate (1) = 0);\n   Assert (Candidate (5) = 4);\n   Assert (Candidate (8) = 24);\n   Assert (Candidate (10) = 81);\n   Assert (Candidate (12) = 274);\n   Assert (Candidate (14) = 927);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_64_vowels_count", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Vowels_Count (S : String) return Integer;\n   -- Write a function vowels_count which takes a string representing\n   -- a word as input and returns the number of vowels in the string.\n   -- Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n   -- vowel, but only when it is at the end of the given word.\n   -- Example:\n   -- >>> Vowels_Count (abcde)\n   -- 2\n   -- >>> Vowels_Count (ACEDY)\n   -- 3\n\n\n   function Vowels_Count (S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_64_vowels_count.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Integer renames Vowels_Count;\nbegin\n   Assert (Candidate (abcde) = 2);\n   Assert (Candidate (Alone) = 3);\n   Assert (Candidate (key) = 2);\n   Assert (Candidate (bye) = 1);\n   Assert (Candidate (keY) = 2);\n   Assert (Candidate (bYe) = 1);\n   Assert (Candidate (ACEDY) = 3);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_65_circular_shift", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Circular_Shift (X : Integer; S : Integer) return String;\n   -- Circular shift the digits of the integer x, shift the digits right by shift\n   -- and return the result as a string.\n   -- If shift > number of digits, return digits reversed.\n   -- >>> Circular_Shift (12, 1)\n   -- 21\n   -- >>> Circular_Shift (12, 2)\n   -- 12\n\n\n   function Circular_Shift (X : Integer; S : Integer) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_65_circular_shift.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : Integer; S : Integer) return String renames Circular_Shift;\nbegin\n   Assert (Candidate (100, 2) = 001);\n   Assert (Candidate (12, 2) = 12);\n   Assert (Candidate (97, 8) = 79);\n   Assert (Candidate (12, 1) = 21);\n   Assert (Candidate (11, 101) = 11);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_66_digitSum", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Digit_Sum (S : String) return Integer;\n   -- Task\n   -- Write a function that takes a string as input and returns the sum of the upper characters only'\n   -- ASCII codes.\n   -- Examples:\n   -- digitSum(\"\") => 0\n   -- digitSum(\"abAB\") => 131\n   -- digitSum(\"abcCd\") => 67\n   -- digitSum(\"helloE\") => 69\n   -- digitSum(\"woArBld\") => 131\n   -- digitSum(\"aAaaaXa\") => 153\n\n\n   function Digit_Sum (S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_66_digitSum.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Integer renames Digit_Sum;\nbegin\n   Assert (Candidate () = 0);\n   Assert (Candidate (abAB) = 131);\n   Assert (Candidate (abcCd) = 67);\n   Assert (Candidate (helloE) = 69);\n   Assert (Candidate (woArBld) = 131);\n   Assert (Candidate (aAaaaXa) = 153);\n   Assert (Candidate ( How are yOu?) = 151);\n   Assert (Candidate (You arE Very Smart) = 327);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_67_fruit_distribution", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Fruit_Distribution (S : String; N : Integer) return Integer;\n   -- In this task, you will be given a string that represents a number of apples and oranges \n   -- that are distributed in a basket of fruit this basket contains \n   -- apples, oranges, and mango fruits. Given the string that represents the total number of \n   -- the oranges and apples and an integer that represent the total number of the fruits \n   -- in the basket return the number of the mango fruits in the basket.\n   -- for examble:\n   -- fruit_distribution(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n   -- fruit_distribution(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n   -- fruit_distribution(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n   -- fruit_distribution(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n\n\n   function Fruit_Distribution (S : String; N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_67_fruit_distribution.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String; N : Integer) return Integer renames Fruit_Distribution;\nbegin\n   Assert (Candidate (5 apples and 6 oranges, 19) = 8);\n   Assert (Candidate (5 apples and 6 oranges, 21) = 10);\n   Assert (Candidate (0 apples and 1 oranges, 3) = 2);\n   Assert (Candidate (1 apples and 0 oranges, 3) = 2);\n   Assert (Candidate (2 apples and 3 oranges, 100) = 95);\n   Assert (Candidate (2 apples and 3 oranges, 5) = 0);\n   Assert (Candidate (1 apples and 100 oranges, 120) = 19);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_71_triangle_area", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Triangle_Area (A : Integer; B : Integer; C : Integer) return Float;\n   -- Given the lengths of the three sides of a triangle. Return the area of\n   -- the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n   -- Otherwise return -1\n   -- Three sides make a valid triangle when the sum of any two sides is greater \n   -- than the third side.\n   -- Example:\n   -- triangle_area(3, 4, 5) == 6.00\n   -- triangle_area(1, 2, 10) == -1\n\n\n   function Triangle_Area (A : Integer; B : Integer; C : Integer) return Float", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_71_triangle_area.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer; B : Integer; C : Integer) return Float renames Triangle_Area;\nbegin\n   Assert (Candidate (3, 4, 5) = 6.0);\n   Assert (Candidate (1, 2, 10) = -1);\n   Assert (Candidate (4, 8, 5) = 8.18);\n   Assert (Candidate (2, 2, 2) = 1.73);\n   Assert (Candidate (1, 2, 3) = -1);\n   Assert (Candidate (10, 5, 7) = 16.25);\n   Assert (Candidate (2, 6, 3) = -1);\n   Assert (Candidate (1, 1, 1) = 0.43);\n   Assert (Candidate (2, 2, 10) = -1);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_75_is_multiply_prime", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Multiply_Prime (A : Integer) return Boolean;\n   -- Write a function that returns true if the given number is the multiplication of 3 prime numbers\n   -- and false otherwise.\n   -- Knowing that (a) is less then 100. \n   -- Example:\n   -- is_multiply_prime(30) == True\n   -- 30 = 2 * 3 * 5\n\n\n   function Is_Multiply_Prime (A : Integer) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_75_is_multiply_prime.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer) return Boolean renames Is_Multiply_Prime;\nbegin\n   Assert (Candidate (5) = False);\n   Assert (Candidate (30) = True);\n   Assert (Candidate (8) = True);\n   Assert (Candidate (10) = False);\n   Assert (Candidate (125) = True);\n   Assert (Candidate (105) = True);\n   Assert (Candidate (126) = False);\n   Assert (Candidate (729) = False);\n   Assert (Candidate (891) = False);\n   Assert (Candidate (1001) = True);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_76_is_simple_power", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Simple_Power (X : Integer; N : Integer) return Boolean;\n   -- Your task is to write a function that returns true if a number x is a simple\n   -- power of n and false in other cases.\n   -- x is a simple power of n if n**int=x\n   -- For example:\n   -- is_simple_power(1, 4) => true\n   -- is_simple_power(2, 2) => true\n   -- is_simple_power(8, 2) => true\n   -- is_simple_power(3, 2) => false\n   -- is_simple_power(3, 1) => false\n   -- is_simple_power(5, 3) => false\n\n\n   function Is_Simple_Power (X : Integer; N : Integer) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_76_is_simple_power.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : Integer; N : Integer) return Boolean renames Is_Simple_Power;\nbegin\n   Assert (Candidate (16, 2) = True);\n   Assert (Candidate (143214, 16) = False);\n   Assert (Candidate (4, 2) = True);\n   Assert (Candidate (9, 3) = True);\n   Assert (Candidate (16, 4) = True);\n   Assert (Candidate (24, 2) = False);\n   Assert (Candidate (128, 4) = False);\n   Assert (Candidate (12, 6) = False);\n   Assert (Candidate (1, 1) = True);\n   Assert (Candidate (1, 12) = True);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_77_iscube", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Iscube (A : Integer) return Boolean;\n   -- Write a function that takes an integer a and returns True \n   -- if this ingeger is a cube of some integer number.\n   -- Note: you may assume the input is always valid.\n   -- Examples:\n   -- iscube(1) ==> True\n   -- iscube(2) ==> False\n   -- iscube(-1) ==> True\n   -- iscube(64) ==> True\n   -- iscube(0) ==> True\n   -- iscube(180) ==> False\n\n\n   function Iscube (A : Integer) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_77_iscube.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer) return Boolean renames Iscube;\nbegin\n   Assert (Candidate (1) = True);\n   Assert (Candidate (2) = False);\n   Assert (Candidate (-1) = True);\n   Assert (Candidate (64) = True);\n   Assert (Candidate (180) = False);\n   Assert (Candidate (1000) = True);\n   Assert (Candidate (0) = True);\n   Assert (Candidate (1729) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_78_hex_key", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Hex_Key (N : String) return Integer;\n   -- You have been tasked to write a function that receives \n   -- a hexadecimal number as a string and counts the number of hexadecimal \n   -- digits that are primes (prime number, or a prime, is a natural number \n   -- greater than 1 that is not a product of two smaller natural numbers).\n   -- Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n   -- Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n   -- So you have to determine a number of the following digits: 2, 3, 5, 7, \n   -- B (=decimal 11), D (=decimal 13).\n   -- Note: you may assume the input is always correct or empty string, \n   -- and symbols A,B,C,D,E,F are always uppercase.\n   -- Examples:\n   -- For num = \"AB\" the output should be 1.\n   -- For num = \"1077E\" the output should be 2.\n   -- For num = \"ABED1A33\" the output should be 4.\n   -- For num = \"123456789ABCDEF0\" the output should be 6.\n   -- For num = \"2020\" the output should be 2.\n\n\n   function Hex_Key (N : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_78_hex_key.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : String) return Integer renames Hex_Key;\nbegin\n   Assert (Candidate (AB) = 1);\n   Assert (Candidate (1077E) = 2);\n   Assert (Candidate (ABED1A33) = 4);\n   Assert (Candidate (2020) = 2);\n   Assert (Candidate (123456789ABCDEF0) = 6);\n   Assert (Candidate (112233445566778899AABBCCDDEEFF00) = 12);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_79_decimal_to_binary", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Decimal_To_Binary (D : Integer) return String;\n   -- You will be given a number in decimal form and your task is to convert it to\n   -- binary format. The function should return a string, with each character representing a binary\n   -- number. Each character in the string will be '0' or '1'.\n   -- There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n   -- The extra characters are there to help with the format.\n   -- Examples:\n   -- decimal_to_binary(15)   # returns \"db1111db\"\n   -- decimal_to_binary(32)   # returns \"db100000db\"\n\n\n   function Decimal_To_Binary (D : Integer) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_79_decimal_to_binary.py", "prompt_terminology": "reworded", "tests": "   function Candidate (D : Integer) return String renames Decimal_To_Binary;\nbegin\n   Assert (Candidate (0) = db0db);\n   Assert (Candidate (32) = db100000db);\n   Assert (Candidate (103) = db1100111db);\n   Assert (Candidate (15) = db1111db);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_80_is_happy", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Happy (S : String) return Boolean;\n   -- You are given a string s.\n   -- Your task is to check if the string is hapadb or not.\n   -- A string is hapadb if its length is at least 3 and every 3 consecutive letters are distinct\n   -- For example:\n   -- is_hapadb(a) => False\n   -- is_hapadb(aa) => False\n   -- is_hapadb(abcd) => True\n   -- is_hapadb(aabb) => False\n   -- is_hapadb(adb) => True\n   -- is_hapadb(xyy) => False\n\n\n   function Is_Happy (S : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_80_is_happy.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Boolean renames Is_Happy;\nbegin\n   Assert (Candidate (a) = False);\n   Assert (Candidate (aa) = False);\n   Assert (Candidate (abcd) = True);\n   Assert (Candidate (aabb) = False);\n   Assert (Candidate (adb) = True);\n   Assert (Candidate (xyy) = False);\n   Assert (Candidate (iopaxpoi) = True);\n   Assert (Candidate (iopaxioi) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_82_prime_length", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Prime_Length (S : String) return Boolean;\n   -- Write a function that takes a string and returns True if the string\n   -- length is a prime number or False otherwise\n   -- Examples\n   -- prime_length('Hello') == True\n   -- prime_length('abcdcba') == True\n   -- prime_length('kittens') == True\n   -- prime_length('orange') == False\n\n\n   function Prime_Length (S : String) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_82_prime_length.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Boolean renames Prime_Length;\nbegin\n   Assert (Candidate (Hello) = True);\n   Assert (Candidate (abcdcba) = True);\n   Assert (Candidate (kittens) = True);\n   Assert (Candidate (orange) = False);\n   Assert (Candidate (wow) = True);\n   Assert (Candidate (world) = True);\n   Assert (Candidate (MadaM) = True);\n   Assert (Candidate (Wow) = True);\n   Assert (Candidate () = False);\n   Assert (Candidate (HI) = True);\n   Assert (Candidate (go) = True);\n   Assert (Candidate (gogo) = False);\n   Assert (Candidate (aaaaaaaaaaaaaaa) = False);\n   Assert (Candidate (Madam) = True);\n   Assert (Candidate (M) = False);\n   Assert (Candidate (0) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_83_starts_one_ends", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Starts_One_Ends (N : Integer) return Integer;\n   -- Given a positive integer n, return the count of the numbers of n-digit\n   -- positive integers that start or end with 1.\n\n\n   function Starts_One_Ends (N : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_83_starts_one_ends.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return Integer renames Starts_One_Ends;\nbegin\n   Assert (Candidate (1) = 1);\n   Assert (Candidate (2) = 18);\n   Assert (Candidate (3) = 180);\n   Assert (Candidate (4) = 1800);\n   Assert (Candidate (5) = 18000);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_84_solve", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Solve (N : Integer) return String;\n   -- Given a positive integer N, return the total sum of its digits in binary.\n   -- Example\n   -- For N = 1000, the sum of digits will be 1 the output should be \"1\".\n   -- For N = 150, the sum of digits will be 6 the output should be \"110\".\n   -- For N = 147, the sum of digits will be 12 the output should be \"1100\".\n   -- Variables:\n   -- @N integer\n   -- Constraints: 0 \u2264 N \u2264 10000.\n   -- Output:\n   -- a string of binary number\n\n\n   function Solve (N : Integer) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_84_solve.py", "prompt_terminology": "reworded", "tests": "   function Candidate (N : Integer) return String renames Solve;\nbegin\n   Assert (Candidate (1000) = 1);\n   Assert (Candidate (150) = 110);\n   Assert (Candidate (147) = 1100);\n   Assert (Candidate (333) = 1001);\n   Assert (Candidate (963) = 10010);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_86_anti_shuffle", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Anti_Shuffle (S : String) return String;\n   -- Write a function that takes a string and returns an ordered version of it.\n   -- Ordered version of string, is a string where all words (separated by space)\n   -- are replaced by a new word where all the characters arranged in\n   -- ascending order based on ascii value.\n   -- Note: You should keep the order of words and blank spaces in the sentence.\n   -- For example:\n   -- anti_shuffle('Hi') returns 'Hi'\n   -- anti_shuffle('hello') returns 'ehllo'\n   -- anti_shuffle('Hello World!!!') returns 'Hello !!!Wdlor'\n\n\n   function Anti_Shuffle (S : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_86_anti_shuffle.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return String renames Anti_Shuffle;\nbegin\n   Assert (Candidate (Hi) = Hi);\n   Assert (Candidate (hello) = ehllo);\n   Assert (Candidate (number) = bemnru);\n   Assert (Candidate (abcd) = abcd);\n   Assert (Candidate (Hello World!!!) = Hello !!!Wdlor);\n   Assert (Candidate () = );\n   Assert (Candidate (Hi. My name is Mister Robot. How are you?) = .Hi My aemn is Meirst .Rboot How aer ?ouy);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_89_encrypt", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Encrypt (S : String) return String;\n   -- Create a function encrypt that takes a string as an argument and\n   -- returns a string encrypted with the alphabet being rotated. \n   -- The alphabet should be rotated in a manner such that the letters \n   -- shift down by two multiplied to two places.\n   -- For example:\n   -- encrypt('hi') returns 'lm'\n   -- encrypt('asdfghjkl') returns 'ewhjklnop'\n   -- encrypt('gf') returns 'kj'\n   -- encrypt('et') returns 'ix'\n\n\n   function Encrypt (S : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_89_encrypt.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return String renames Encrypt;\nbegin\n   Assert (Candidate (hi) = lm);\n   Assert (Candidate (asdfghjkl) = ewhjklnop);\n   Assert (Candidate (gf) = kj);\n   Assert (Candidate (et) = ix);\n   Assert (Candidate (faewfawefaewg) = jeiajeaijeiak);\n   Assert (Candidate (hellomyfriend) = lippsqcjvmirh);\n   Assert (Candidate (dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh) = hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl);\n   Assert (Candidate (a) = e);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_91_is_bored", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Is_Bored (S : String) return Integer;\n   -- You'll be given a string of words, and your task is to count the number\n   -- of boredoms. A boredom is a sentence that starts with the word \"I\".\n   -- Sentences are delimited by '.', '?' or '!'.\n   -- For example:\n   -- >>> Is_Bored (Hello world)\n   -- 0\n   -- >>> Is_Bored (The sky is blue. The sun is shining. I love this weather)\n   -- 1\n\n\n   function Is_Bored (S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_91_is_bored.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Integer renames Is_Bored;\nbegin\n   Assert (Candidate (Hello world) = 0);\n   Assert (Candidate (Is the sky blue?) = 0);\n   Assert (Candidate (I love It !) = 1);\n   Assert (Candidate (bIt) = 0);\n   Assert (Candidate (I feel good today. I will be productive. will kill It) = 2);\n   Assert (Candidate (You and I are going for a walk) = 0);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_92_any_int", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Any_Int (X : Float; Y : Float; Z : Float) return Boolean;\n   -- Create a function that takes 3 numbers.\n   -- Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n   -- Returns false in any other cases.\n   -- Examples\n   -- any_int(5, 2, 7) \u279e True\n   -- any_int(3, 2, 2) \u279e False\n   -- any_int(3, -2, 1) \u279e True\n   -- any_int(3.6, -2.2, 2) \u279e False\n\n\n   function Any_Int (X : Float; Y : Float; Z : Float) return Boolean", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_92_any_int.py", "prompt_terminology": "reworded", "tests": "   function Candidate (X : Float; Y : Float; Z : Float) return Boolean renames Any_Int;\nbegin\n   Assert (Candidate (2, 3, 1) = True);\n   Assert (Candidate (2.5, 2, 3) = False);\n   Assert (Candidate (1.5, 5, 3.5) = False);\n   Assert (Candidate (2, 6, 2) = False);\n   Assert (Candidate (4, 2, 2) = True);\n   Assert (Candidate (2.2, 2.2, 2.2) = False);\n   Assert (Candidate (-4, 6, 2) = True);\n   Assert (Candidate (2, 1, 1) = True);\n   Assert (Candidate (3, 4, 7) = True);\n   Assert (Candidate (3.0, 4, 7) = False);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_93_encode", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Encode (M : String) return String;\n   -- Write a function that takes a message, and encodes in such a \n   -- way that it swaps case of all letters, replaces all vowels in \n   -- the message with the letter that appears 2 places ahead of that \n   -- vowel in the english alphabet. \n   -- Assume only letters. \n   -- Examples:\n   -- >>> Encode (test)\n   -- TGST\n   -- >>> Encode (This is a message)\n   -- tHKS KS C MGSSCGG\n\n\n   function Encode (M : String) return String", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_93_encode.py", "prompt_terminology": "reworded", "tests": "   function Candidate (M : String) return String renames Encode;\nbegin\n   Assert (Candidate (TEST) = tgst);\n   Assert (Candidate (Mudasir) = mWDCSKR);\n   Assert (Candidate (YES) = ygs);\n   Assert (Candidate (This is a message) = tHKS KS C MGSSCGG);\n   Assert (Candidate (I DoNt KnOw WhAt tO WrItE) = k dQnT kNqW wHcT Tq wRkTg);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_97_multiply", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Multiply (A : Integer; B : Integer) return Integer;\n   -- Complete the function that takes two integers and returns \n   -- the product of their unit digits.\n   -- Assume the input is always valid.\n   -- Examples:\n   -- multiply(148, 412) should return 16.\n   -- multiply(19, 28) should return 72.\n   -- multiply(2020, 1851) should return 0.\n   -- multiply(14,-15) should return 20.\n\n\n   function Multiply (A : Integer; B : Integer) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_97_multiply.py", "prompt_terminology": "reworded", "tests": "   function Candidate (A : Integer; B : Integer) return Integer renames Multiply;\nbegin\n   Assert (Candidate (148, 412) = 16);\n   Assert (Candidate (19, 28) = 72);\n   Assert (Candidate (2020, 1851) = 0);\n   Assert (Candidate (14, -15) = 20);\n   Assert (Candidate (76, 67) = 42);\n   Assert (Candidate (17, 27) = 49);\n   Assert (Candidate (0, 1) = 0);\n   Assert (Candidate (0, 0) = 0);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_98_count_upper", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Count_Upper (S : String) return Integer;\n   -- Given a string s, count the number of uppercase vowels in even indices.\n   -- For example:\n   -- count_upper('aBCdEf') returns 1\n   -- count_upper('abcdefg') returns 0\n   -- count_upper('dBBE') returns 0\n\n\n   function Count_Upper (S : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_98_count_upper.py", "prompt_terminology": "reworded", "tests": "   function Candidate (S : String) return Integer renames Count_Upper;\nbegin\n   Assert (Candidate (aBCdEf) = 1);\n   Assert (Candidate (abcdefg) = 0);\n   Assert (Candidate (dBBE) = 0);\n   Assert (Candidate (B) = 0);\n   Assert (Candidate (U) = 1);\n   Assert (Candidate () = 0);\n   Assert (Candidate (EEEE) = 2);\nend Main;\n", "stop_tokens": ["\n   end "]}
{"name": "HumanEval_99_closest_integer", "language": "adb", "prompt": "with Ada.Assertions; use Ada.Assertions;\n\nprocedure Main is\n\n   function Closest_Integer (V : String) return Integer;\n   -- Create a function that takes a value (string) representing a number\n   -- and returns the closest integer to it. If the number is equidistant\n   -- from two integers, round it away from zero.\n   -- Examples\n   -- >>> Closest_Integer (10)\n   -- 10\n   -- >>> Closest_Integer (15.3)\n   -- 15\n   -- Note:\n   -- Rounding away from zero means that if the given number is equidistant\n   -- from two integers, the one you should return is the one that is the\n   -- farthest from zero. For example closest_integer(\"14.5\") should\n   -- return 15 and closest_integer(\"-14.5\") should return -15.\n\n\n   function Closest_Integer (V : String) return Integer", "doctests": "transform", "original": "/workspaces/MultiPL-E/datasets/../datasets/originals/HumanEval_99_closest_integer.py", "prompt_terminology": "reworded", "tests": "   function Candidate (V : String) return Integer renames Closest_Integer;\nbegin\n   Assert (Candidate (10) = 10);\n   Assert (Candidate (14.5) = 15);\n   Assert (Candidate (-15.5) = -16);\n   Assert (Candidate (15.3) = 15);\n   Assert (Candidate (0) = 0);\nend Main;\n", "stop_tokens": ["\n   end "]}
